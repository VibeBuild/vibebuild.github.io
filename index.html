<!DOCTYPE html>
<html lang="pt-br">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
		<title>Projeto - An√°lise e Resenha</title>
		<style>
			* { margin: 0; padding: 0; box-sizing: border-box; scroll-behavior: smooth; }
			body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #121212; color: white; }
			header { background-color: #1f1f1f; padding: 20px; position: fixed; width: 100%; top: 0; z-index: 1000; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
			nav { display: flex; justify-content: space-between; align-items: center; max-width: 1200px; margin: auto; }
			nav h1 { color: #00ffcc; }
			nav ul { list-style: none; display: flex; gap: 20px; }
			nav ul li a { color: white; text-decoration: none; transition: color 0.3s; }
			nav ul li a:hover { color: #00ffcc; }
			section { padding: 100px 20px 60px; max-width: 1000px; margin: auto; }
			section h2 { color: #00ffcc; margin-bottom: 20px; }
			h3 { color: #00ffcc; margin-top: 40px; margin-bottom: 10px; }
			.hero { background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.7)), url('https://i.ibb.co/LXQdK614/Chat-GPT-Image-May-25-2025-02-08-55-PM.png') center/cover; height: 60vh; display: flex; justify-content: center; align-items: center; text-align: center; }
			.hero h1 { font-size: 3rem; color: white; }
			.hero p { margin-top: 10px; color: #ccc; }
			footer { background-color: #1f1f1f; text-align: center; padding: 20px; color: #aaa; }
			pre { background-color: #1e1e1e; padding: 15px; border-radius: 10px; overflow-x: auto; color: #00ffcc; margin-bottom: 20px; }
			.sub-info { background-color: #1e1e1e; border-left: 5px solid #00ffcc; padding: 15px 20px; margin-top: 15px; border-radius: 8px; color: #ccc; }
			strong { color: #00ffcc; }
			.code-container {
			position: relative;
			}
            .positivos strong {
                color: rgb(92, 182, 255);
            }
            .negativos strong {
                color: rgb(255, 115, 115);
            }
            .detalhes strong {
                color: rgb(247, 255, 171);
            }
            pre.prompt {
                color: white !important;
            }
            .about {
    background-color: #1e1e1e;
    padding: 40px;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    max-width: 900px;
    margin: 50px auto;
    font-family: 'Courier New', monospace;
}
img:not(.noborder) {
 border: 5px solid #34ff89;
}

img {
width: 60%; height: auto;
margin:10px;
}

.grande {
	width: 80%;
}

.about h2 {
    color: #00ffcc;
    margin-bottom: 20px;
    text-align: center;
}

.about h3 {
    color: #00ffcc;
    margin-top: 30px;
}

.about p {
    margin-bottom: 15px;
    color: #ccc;
}

.about ul, .about ol {
    margin-left: 20px;
    margin-bottom: 20px;
    color: #ccc;
}

.about li {
    margin-bottom: 8px;
}

.about a {
    color: #9c67ff;
    text-decoration: none;
}

.about a:hover {
    text-decoration: underline;
}

.about pre {
    background-color: #121212;
    padding: 15px;
    border-radius: 8px;
    overflow-x: auto;
    color: #00ffcc;
    margin: 10px 0;
}

.about blockquote {
    border-left: 4px solid #00ffcc;
    padding-left: 15px;
    color: #aaa;
    margin-top: 20px;
    font-style: italic;
}

.ascii-art {
    text-align: center;
    margin-bottom: 20px;
}

.ascii-art pre {
    display: inline-block;
    text-align: left;
}

			.copy-button {
			position: absolute;
			top: 10px;
			right: 10px;
			background-color: #00ffcc;
			color: #121212;
			border: none;
			padding: 5px 10px;
			border-radius: 5px;
			cursor: pointer;
			font-size: 0.8rem;
			opacity: 0.7;
			transition: opacity 0.3s;
			}
			.copy-button:hover {
			opacity: 1;
			}
            .container_ {
                gap: 20px;
            }
            .container_ a {
                color: #9c67ff
            }
            img {
                padding-top: 20px;
            }
.download-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 50px 0;
}

.download-button {
    display: inline-block;
    background-color: #00ffcc;
    color: #121212;
    padding: 14px 28px;
    border-radius: 10px;
    text-decoration: none;
    font-weight: bold;
    font-size: 1rem;
    transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
    box-shadow: 0 5px 20px rgba(0, 255, 204, 0.3);
}

.download-button:hover {
    background-color: #00e6b8;
    transform: translateY(-3px);
    box-shadow: 0 8px 30px rgba(0, 255, 204, 0.5);
}

.download-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 10px rgba(0, 255, 204, 0.2);
}
.downloadinbar {
    color: #00e6b8;
}
.downloadinbar:hover {
     text-shadow:
        -1px -1px 0 rgb(1, 69, 78),
         1px -1px 0 rgb(14, 175, 148),
        -1px  1px 0 rgb(59, 86, 235),
         1px  1px 0 rgb(20, 126, 126);
}
		</style>
	</head>
	<body>
		<header>
			<nav>
				<h1>Vibe Build</h1>
				<ul>
					<li><a href="#objetivo">Objetivo</a></li>
					<li><a href="#ambiente">Ambiente</a></li>
                    <li><a href="#autor">Autor</a></li>
					<li><a href="#foco">Focos</a></li>
					<li><a href="#desenvolvimento">Desenvolvimento</a></li>
                    <li><a href="#conclusao">Conclus√£o</a></li>
                    <li><a href="https://vibebuild.github.io/VibeBuild" download class="downloadinbar">Download</a></li>
				</ul>
			</nav>
		</header>
		<div class="hero">
			<div>
				<h1>Projeto: VibeBuild</h1>
				<p>Documenta√ß√£o, processo e resultados</p>
			</div>
		</div>
			<section id="objetivo" class="container_">
				<h2>Objetivo</h2>
				<p>Desenvolver um script de build para compilar / gerar um execut√°vel de pequenos c√≥digos, depois veremos a necessidade de trabalhar com mais de um arquivo por vez. Sendo interessante tamb√©m a id√©ia de poder rodar os c√≥digos, principalmente os que n√£o s√£o interpretados.<br><br><br>
                <h5>Expectativas:</h5><br>
                - Terminar em um dia [realizado, com pequenas altera√ß√µes no outro dia, nada demais]<br>
                - Compilar corretamente cada arquivo de forma separada e enviar para uma pasta (./bin/) [realizado]<br>
                - Ser simples de utilizar [realizado]
                </p>
            </section>
			<section id="ambiente" class="container_">
				<h2>Ambiente</h2>
				<p>
					- OS: Arch Linux x86_64<br>
					- Browser: Chromium 136.0.7103.113<br>
					- Shell: GNU bash, version 5.2.37(1)-release<br>
                    - IA: ChatGPT4o Openai<br>
                    - Linguagem: Makefile (trocada logo no in√≠cio do projeto por BashScript)<br>
                    - Terminal emulator: Kitty 0.42.0
				</p>
			</section>
            <section id="autor" class="container_">
				<h2>Autor</h2>
				<p>
					- Turma 1203<br><br>
					- Renato L√≥is Marcondes da Silva, N¬∞ 22<br>
          			- Email Institucional: 244084.aluno@iserj.edu.br<br><br>
          			- Luiz Eduardo Guerra Cidade, N¬∞ 16<br>
          			- Email Institucional: 244077.aluno@iserj.edu.br<br><br>
			        - Davi Eduardo Santos de Lima, N¬∞ 7<br>
          			- Email Institucional: 244065.aluno@iserj.edu.br<br>
				</p>
			</section>
			<br><br>
			<section id="foco" class="container_">
				<h2>Focos do Projeto</h2>
				<p>- Agilizar a compila√ß√£o e execu√ß√£o de c√≥digos simples e pequenos em diferentes linguagens.<br>
					- Reduzir a necessidade de comandos manuais.<br>
					- Proporcionar uma experi√™ncia mais fluida para testes r√°pidos de scripts.
				</p>
			</section>
			<br><br>
		<section id="desenvolvimento">
			<h1>Desenvolvimento do C√≥digo</h1>
			<br>
			<h2>1. Makefile Inicial</h2>
			<p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
criar um script makefile que receba "make nomedoarquivo" e entao,
se for c++ ele compilar para c++, se for c, para c, se for python,
so rodar python e nome do arquivo</pre>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
# Uso:
# make nome_do_arquivo (sem extens√£o)

FILE=$(firstword $(MAKECMDGOALS))

EXTENSION = $(shell find . -maxdepth 1 -type f -name "$(FILE).*" | sed -n 's/.*\.\([^.]*\)$$/\1/p')

ifeq ($(EXTENSION),cpp)
	COMMAND = g++ -o $(FILE) $(FILE).cpp && ./$(FILE)
endif

ifeq ($(EXTENSION),c)
	COMMAND = gcc -o $(FILE) $(FILE).c && ./$(FILE)
endif

ifeq ($(EXTENSION),py)
	COMMAND = python3 $(FILE).py
endif

ifeq ($(EXTENSION),)
	COMMAND = echo "Arquivo $(FILE) n√£o encontrado."
endif

all:
	@$(COMMAND)</code>
        </pre>
			</div>
			<div class="resultado">
				<h3>Resultado</h3>
				<p>O Makefile apresentou limita√ß√µes na execu√ß√£o direta. Conseguiu compilar c√≥digos C e C++, mas n√£o rodou corretamente c√≥digo Python.</p>
				<div class="sub-info">
					<p>Ap√≥s isso, surgiu a ideia de adicionar a fun√ß√£o de compilar mais de um c√≥digo gerando diversos bin√°rios, com somente um comando, deixando de lado moment√¢neamente o problema de n√£o rodar Python. O c√≥digo Makefile notou-se complexo, pois como dito, n√£o tenho experi√™ncia nem conhecimento significativo dessa ferramenta, ent√£o decidimos trocar para bash script.
					</p>
				</div>
			</div>
            <img src="https://i.ibb.co/7N1hr8s0/makefileerror.png" alt="makefile code output">
			<br><br>
			<br><br>
			<br><br>
			<br><br>
			<h2>2. Migra√ß√£o para Shell Script</h2>
			<p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
um codigo shell que receba o nome do arquivo com ou sem extensao,
se for c, faz gcc, c++ g++, somente isso, e crie ./bin/ se nao existir
e mande para la o bin√°rio
        </pre>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Verifica se foi passado argumento
if [ -z "$1" ]; then
    echo "‚ùå Uso: ./build.sh nome_do_arquivo[.c|.cpp]"
    exit 1
fi

# Nome base e extens√£o
input="$1"
name="${input%.*}"  # Remove extens√£o, se tiver
ext="${input##*.}"  # Pega a extens√£o

# Se n√£o tiver extens√£o, tenta descobrir
if [ "$ext" = "$input" ]; then
    if [ -f "$input.c" ]; then
        ext="c"
        input="$input.c"
    elif [ -f "$input.cpp" ]; then
        ext="cpp"
        input="$input.cpp"
    else
        echo "‚ùå Arquivo '$input.[c|cpp]' n√£o encontrado."
        exit 1
    fi
fi

# Cria pasta bin se n√£o existir
mkdir -p bin

# Compila de acordo com a extens√£o
if [ "$ext" = "c" ]; then
    echo "üîß Compilando C: $input -> bin/$name"
    gcc "$input" -o "bin/$name"
elif [ "$ext" = "cpp" ]; then
    echo "üîß Compilando C++: $input -> bin/$name"
    g++ "$input" -o "bin/$name"
else
    echo "‚ùå Extens√£o .$ext n√£o suportada."
    exit 1
fi

# Mensagem final
if [ $? -eq 0 ]; then
    echo "‚úÖ Bin√°rio criado em: bin/$name"
else
    echo "‚ùå Erro na compila√ß√£o."
    exit 1
fi
			</code></pre>
			</div>
			<br><br>
			<p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
agora ele vai receber varios arquivos
				</pre>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Verifica se recebeu pelo menos um arquivo
if [ $# -eq 0 ]; then
    echo "‚ùå Uso: ./build.sh arquivo1 [arquivo2 ...]"
    exit 1
fi

# Cria bin se n√£o existir
mkdir -p bin

# Loop sobre todos os argumentos
for input in "$@"; do
# Remove extens√£o (se tiver)
name="${input%.*}"
ext="${input##*.}"

    # Se n√£o tiver extens√£o, tenta achar
    if [ "$ext" = "$input" ]; then
    if [ -f "$input.c" ]; then
            ext="c"
            input="$input.c"
        elif [ -f "$input.cpp" ]; then
        ext="cpp"
            input="$input.cpp"
            else
            echo "‚ùå Arquivo '$input.[c|cpp]' n√£o encontrado."
            continue
        fi
    fi
    
    # Verifica se o arquivo realmente existe
    if [ ! -f "$input" ]; then
    echo "‚ùå Arquivo '$input' n√£o encontrado."
        continue
    fi
    
    # Compila
    if [ "$ext" = "c" ]; then
        echo "üîß Compilando C: $input -> bin/$name"
        gcc "$input" -o "bin/$name"
    elif [ "$ext" = "cpp" ]; then
        echo "üîß Compilando C++: $input -> bin/$name"
        g++ "$input" -o "bin/$name"
    else
        echo "‚ùå Extens√£o '.$ext' n√£o suportada para '$input'."
        continue
    fi

    if [ $? -eq 0 ]; then
        echo "‚úÖ Sucesso: bin/$name"
    else
    echo "‚ùå Erro ao compilar: $input"
    fi
done
			</code></pre>
            <img src="https://i.ibb.co/5XPy5kh6/op.png" alt="VibeBuild output">
			</div>
			<div class="resultado">
				<h3>Resultado</h3>
				<p>O c√≥digo j√° se encontra funcional para C e C++, entretanto o uso de emoji deve ser evitado em aplica√ß√µes CLI, ent√£o esse detalhe dever√° ser removido. Al√©m disso, ao compilar diversos arquivos, o output de warnings e erros do compilador causa desconforto visual, ent√£o ser√° necess√°rio um output mais compacto (de preferencia em ingl√™s), al√©m de que o programa dever√° rodar com outras linguagens.</p>
				<div class="sub-info">
                    <p>Uma coisa que alterarei √© que em vez de rodar python diretamente, ser√° copiado o c√≥digo com um shebang (se j√° n√£o existir) para o diret√≥rio bin com permiss√£o de execu√ß√£o. Os warnings e erros de compila√ß√£o ser√£o suprimidos, e aparecer√£o apenas se pedido explicitamente.</p>
				</div>
			</div>
			<br><br>
			<br><br>
			<br><br>
			<br><br>
			<h2>2. Aprimoramento do c√≥digo base</h2>
			<p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
Trocar os emoji, melhor sem ser emoji, e torne mais agradavel 
a vista, no final, faca um relatorio, tem que ser tudo em ingles, 
se tudo ocorreu bem, se houve erro, se sim, mostre quantos deram 
warning, quantos deram erro, e aceite uma flag --info para mostrar 
os warning e erros, se nao, so compile, por padr√£o nao mostre os 
erro do gcc e do g++, etc.</pre>
<p><strong>Vers√£o desenvolvida:</strong></p>
<div class="code-container">
    <button class="copy-button" onclick="copyCode(this)">Copiar</button>
    <pre><code class="language-bash">
#!/bin/bash

# =============================
# CONFIGURATION
# =============================
BIN_DIR="bin"
mkdir -p "$BIN_DIR"

SHOW_INFO=false
FILES=()

# =============================
# ARGUMENT PARSING
# =============================
for arg in "$@"; do
if [ "$arg" == "--info" ]; then
SHOW_INFO=true
else
        FILES+=("$arg")
    fi
    done

if [ ${#FILES[@]} -eq 0 ]; then
    echo "Usage: ./compiler.sh [--info] file1 [file2 ...]"
    exit 1
fi

# =============================
# INITIALIZATION
# =============================
success_count=0
warning_count=0
error_count=0

declare -A warnings
declare -A errors

# =============================
# BUILD PROCESS
# =============================
for input in "${FILES[@]}"; do

if [ -d "$input" ]; then
continue
fi

    name="${input%.*}"
    ext="${input##*.}"
    
    if [ "$ext" == "$input" ]; then
    if [ -f "$input.c" ]; then
    ext="c"
    input="$input.c"
    elif [ -f "$input.cpp" ]; then
    ext="cpp"
    input="$input.cpp"
    else
            echo "[ERROR] Source file '$input.[c|cpp]' not found."
            ((error_count++))
            errors["$input"]="File not found"
            continue
        fi
        fi
    
        if [ ! -f "$input" ]; then
        echo "[ERROR] Source file '$input' not found."
        ((error_count++))
        errors["$input"]="File not found"
        continue
    fi
    
    echo "Compiling $input -> $BIN_DIR/$name"
    
    compile_cmd=""
    if [ "$ext" == "c" ]; then
    compile_cmd="gcc \"$input\" -o \"$BIN_DIR/$name\""
    elif [ "$ext" == "cpp" ]; then
    compile_cmd="g++ \"$input\" -o \"$BIN_DIR/$name\""
    else
    echo "[ERROR] Unsupported extension '.$ext' for '$input'."
    ((error_count++))
    errors["$input"]="Unsupported extension"
    continue
    fi
    
    if $SHOW_INFO; then
    output=$(eval $compile_cmd 2>&1)
    else
    output=$(eval $compile_cmd 2>&1 >/dev/null)
    fi
    
    status=$?
    
    if [ $status -eq 0 ]; then
    if [[ "$output" == *"warning"* ]]; then
    ((warning_count++))
    warnings["$input"]="$output"
    echo "[WARNING] Compiled with warnings."
    else
    ((success_count++))
    echo "[OK] Compiled successfully."
    fi
    else
    ((error_count++))
    errors["$input"]="$output"
    echo "[ERROR] Failed to compile."
    fi
    done
    
    # =============================
    # REPORT
    # =============================
    echo ""
    echo "================ Build Report ================"
    echo "Total files: $((success_count + warning_count + error_count))"
echo "Successful builds: $success_count"
echo "Builds with warnings: $warning_count"
echo "Failed builds: $error_count"
echo "=============================================="

if $SHOW_INFO; then
if [ ${#warnings[@]} -gt 0 ]; then
        echo ""
        echo "Warnings:"
        for file in "${!warnings[@]}"; do
        echo "---- $file ----"
        echo "${warnings[$file]}"
        echo ""
        done
        fi

    if [ ${#errors[@]} -gt 0 ]; then
    echo ""
        echo "Errors:"
        for file in "${!errors[@]}"; do
            echo "---- $file ----"
            echo "${errors[$file]}"
            echo ""
            done
            fi
            fi
            
            exit 0
        </code></pre>
        <img src="https://i.ibb.co/sJs6RqBq/s1.png" alt="VibeBuild output">
			</div>
            <br><br>
			<p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
agora adicione a funcionalidade de que quando for um c√≥digo python, 
verifique se h√° um shebang como #!usr/bin/env python3, se nao, 
adicione, e copie para bin com permissao de execucao, use chmod 
para isso, para o python, pois gcc e g++ ja o tornam executaveis.
Os arquivos agora s√≥ ser√£o com extens√£o.            
            </pre>
            </pre>
                <div class="sub-info">
                    <p>Aqui percebo que o uso do nome do arquivo sem extens√£o pode gerar ambiguidade, ent√£o essa ideia ser√° deixada de lado.
                </p>
            </div>
            <br>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
                <button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Cria pasta bin se n√£o existir
mkdir -p bin

INFO=false
if [[ $1 == "--info" ]]; then
    INFO=true
    shift
fi

compiled=0
warnings=0
errors=0
unsupported=0

warning_files=()
error_files=()
unsupported_files=()

echo "============== Compilation Started =============="

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        echo "[SKIP] File not found: $file"
        unsupported=$((unsupported + 1))
        unsupported_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"

    case "$ext" in
        c)
            echo "[C   ] Compiling: $filename -> bin/$name"
            output=$(gcc "$file" -o "bin/$name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx)
            echo "[C++ ] Compiling: $filename -> bin/$name"
            output=$(g++ "$file" -o "bin/$name" 2>&1)
            status=$?
            ;;
        py)
            echo "[PY  ] Processing: $filename -> bin/$name"
            # Verifica se possui shebang
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "bin/$name"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env python3'; cat "$file"; } > "bin/$name"
            fi
            chmod +x "bin/$name"
            echo "[ OK ] bin/$name"
            compiled=$((compiled + 1))
            continue
            ;;
        *)
            echo "[SKIP] Unsupported extension: $filename"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            echo "[WARN] bin/$name compiled with warnings"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
            $INFO && echo "$output"
        else
            echo "[ OK ] bin/$name"
        fi
        compiled=$((compiled + 1))
    else
        echo "[FAIL] Compilation failed: $filename"
        errors=$((errors + 1))
        error_files+=("$filename")
        $INFO && echo "$output"
    fi

done

echo
echo "================= Build Report ==================="
echo "Compiled successfully : $compiled"
echo "Warnings             : $warnings"
echo "Errors               : $errors"
echo "Unsupported files    : $unsupported"

if [[ $warnings -gt 0 ]]; then
    echo "-> Warnings in:"
    for w in "${warning_files[@]}"; do
        echo "   - $w"
    done
fi

if [[ $errors -gt 0 ]]; then
    echo "-> Errors in:"
    for e in "${error_files[@]}"; do
        echo "   - $e"
    done
fi

if [[ $unsupported -gt 0 ]]; then
    echo "-> Unsupported files:"
    for u in "${unsupported_files[@]}"; do
        echo "   - $u"
    done
fi

echo "=================================================="
        		</code></pre>
			</div>
			<br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
fa√ßa uma verifica√ß√£o se h√° arquivos com o mesmo nome, 
por exemplo a.c e a.py, nesse caso, capture da entrada 
padr√£o se quer renomear manualmente ou n√£o, por padr√£o 
(se apenas houver enter) entende-se como um n√£o  (com y/N) 
e nesse caso renomeie cada arquivo executavel gerado para 
filename_extension, no caso, ser√£o gerados respectivamente 
a_c e a_py. Essa funcionalidade deve ser implementada no 
c√≥digo. O arquivo original nao deve ter seu nome trocado. 
Se a opcao selecionado for Y, a pessoa dever√° digitar o
nome do bin√°rio a ser gerado, antes de gerar, esse nome 
dever√° passar novamente por verifica√ß√£o, em loop at√© n√£o 
haver conflito. Em caso de y, o binario deve ser o 
bin/inputinserido, em caso de n, dever√° ser bin/b_py. 
Lembre-se de fazer em ingl√™s.
            </pre>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Create bin directory if it doesn't exist
mkdir -p bin

INFO=false
if [[ $1 == "--info" ]]; then
    INFO=true
    shift
fi

compiled=0
warnings=0
errors=0
unsupported=0

warning_files=()
error_files=()
unsupported_files=()

declare -A bin_names
declare -A name_count

# ===========================
# üîç Count base filenames
# ===========================
for file in "$@"; do
    filename=$(basename -- "$file")
    name="${filename%.*}"
    name_count["$name"]=$((name_count["$name"] + 1))
done

# ===========================
# üéØ Define output names
# ===========================
for file in "$@"; do
    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"

    case "$ext" in
        c|cpp|cc|cxx|py)
            if [[ ${name_count["$name"]} -gt 1 ]]; then
                echo "‚ö†Ô∏è  Conflict: '$filename' would generate binary with duplicated name '$name'"
                read -p "Do you want to choose a custom binary name? (y/N): " choice
                choice=${choice,,}

                if [[ "$choice" == "y" ]]; then
                    while true; do
                        read -p "Enter the binary name for '$filename': " custom_name
                        if [[ -z "$custom_name" ]]; then
                            echo "‚ùå Invalid name. Try again."
                        elif [[ -n "${bin_names[$custom_name]}" || -e "bin/$custom_name" ]]; then
                            echo "‚ùå Name '$custom_name' is already in use. Try another one."
                        else
                            bin_names["$filename"]="$custom_name"
                            break
                        fi
                    done
                else
                    bin_names["$filename"]="${name}_${ext}"
                fi
            else
                bin_names["$filename"]="$name"
            fi
            ;;
        *)
            continue
            ;;
    esac
done

# ===========================
# üîß Compilation and Processing
# ===========================
echo "============== Compilation Started =============="

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        echo "[SKIP] File not found: $file"
        unsupported=$((unsupported + 1))
        unsupported_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    ext="${filename##*.}"
    output_name="${bin_names[$filename]:-${filename%.*}}"

    case "$ext" in
        c)
            echo "[C   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx)
            echo "[C++ ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        py)
            echo "[PY  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "bin/$output_name"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env python3'; cat "$file"; } > "bin/$output_name"
            fi
            chmod +x "bin/$output_name"
            echo "[ OK ] bin/$output_name"
            compiled=$((compiled + 1))
            continue
            ;;
        *)
            echo "[SKIP] Unsupported extension: $filename"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            echo "[WARN] bin/$output_name compiled with warnings"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
            $INFO && echo "$output"
        else
            echo "[ OK ] bin/$output_name"
        fi
        compiled=$((compiled + 1))
    else
        echo "[FAIL] Compilation failed: $filename"
        errors=$((errors + 1))
        error_files+=("$filename")
        $INFO && echo "$output"
    fi
done

# ===========================
# üìä Final Build Report
# ===========================
echo
echo "================= Build Report ==================="
echo "Compiled successfully : $compiled"
echo "Warnings              : $warnings"
echo "Errors                : $errors"
echo "Unsupported files     : $unsupported"

[[ $warnings -gt 0 ]] && echo "-> Warnings in:" && for w in "${warning_files[@]}"; do echo "   - $w"; done
[[ $errors -gt 0 ]] && echo "-> Errors in:" && for e in "${error_files[@]}"; do echo "   - $e"; done
[[ $unsupported -gt 0 ]] && echo "-> Unsupported files:" && for u in "${unsupported_files[@]}"; do echo "   - $u"; done

echo "=================================================="
        		</code></pre>
			</div>

            <div class="sub-info">
                <p> A IA voltou a usar emoji pois houve um equ√≠voco, a aba de navega√ß√£o foi trocada e na verdade o desenvolvimento do c√≥digo foi feito por outra que n√£o recebeu os prompts anteriores. E por isso, enviei o c√≥digo novamente. Nota-se a grande capacidade de se adaptar ao contexto por parte da intelig√™ncia artificial.
                </p>
            </div>
            <br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
                se eu tenho b.py e b.c, e eu altero b.py, nao tem conflito 
                mais com b.c, entao nao ha porque mostrar de novo em b.c, 
                e se eu troco b.py para appexec, entao nao posso dar o nome
                appexec para o binario de b.c. Entretanto, se ainda n√£o h√° 
                por exemplo arquivo chamado b, ent√£o posso criar o b para py 
                sem ser chamado aten√ß√£o, o pedido para renomea√ß√£o deve ser 
                instanciado no √∫ltimo caso possivel no caso, se tenho b.py, 
                e b.c, e o primeiro √© b.py, ele deve "compilar" b.py como 
                bin/b e perguntar oq fazer com b.c. e quando perguntar para 
                renomear, tem q estar explicito qual arquivo esta sendo 
                compilado. E se poss√≠vel em bash script, o y/N ser capturado 
                antes do Enter, deve haver uma op√ß√£o 'a', ficando
                a/y/N, sendo 'a' um 'n' para todas os pr√≥ximos casos de conflito. 
                retire os emojis tamb√©m.
            </pre>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Cria pasta bin se n√£o existir
mkdir -p bin

# Verifica se quer modo info
INFO=false
while [[ "$1" == "--info" || "$1" == "-i" ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
    esac
    shift
done

compiled=0
warnings=0
errors=0
unsupported=0

warning_files=()
error_files=()
unsupported_files=()

# Controle de nomes ocupados
declare -A used_names

# Flag para "n√£o perguntar mais, usar name_ext automaticamente"
ASSUME_NO_ALL=false

echo "============== Compilation Started =============="

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        echo "[SKIP] File not found: $file"
        unsupported=$((unsupported + 1))
        unsupported_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"

    output_name="$name"

    # Verificar se o nome j√° est√° em uso
    if [[ -n "${used_names[$output_name]}" ]]; then
        echo "Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'."

        if $ASSUME_NO_ALL; then
            output_name="${name}_${ext}"
            echo "-> Automatically renaming '$filename' to bin/$output_name due to previous 'a' choice."
        else
            while true; do
                echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                read -n 1 -r choice
                echo
                if [[ "$choice" =~ ^[Yy]$ ]]; then
                    while true; do
                        read -p "Enter new name for '$filename': " newname
                        if [[ -z "$newname" ]]; then
                            echo "Name cannot be empty."
                            continue
                        fi
                        if [[ -n "${used_names[$newname]}" ]]; then
                            echo "Name 'bin/$newname' is already in use for '${used_names[$newname]}'."
                            continue
                        fi
                        output_name="$newname"
                        break
                    done
                    break
                elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                    output_name="${name}_${ext}"
                    break
                elif [[ "$choice" =~ ^[Aa]$ ]]; then
                    output_name="${name}_${ext}"
                    ASSUME_NO_ALL=true
                    echo "-> Automatically applying 'name_ext' for all next conflicts."
                    break
                else
                    echo "Please answer y, n or a."
                fi
            done
        fi
    fi

    # Registrar nome como usado
    used_names["$output_name"]="$filename"

    # Compila√ß√£o/Processamento
    case "$ext" in
        c)
            echo "[C   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx)
            echo "[C++ ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        py)
            echo "[PY  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "bin/$output_name"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env python3'; cat "$file"; } > "bin/$output_name"
            fi
            chmod +x "bin/$output_name"
            echo "[ OK ] bin/$output_name"
            compiled=$((compiled + 1))
            continue
            ;;
        *)
            echo "[SKIP] Unsupported extension: $filename"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            echo "[WARN] bin/$output_name compiled with warnings"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
            $INFO && echo "$output"
        else
            echo "[ OK ] bin/$output_name"
        fi
        compiled=$((compiled + 1))
    else
        echo "[FAIL] Compilation failed: $filename"
        errors=$((errors + 1))
        error_files+=("$filename")
        $INFO && echo "$output"
    fi

done

echo
echo "================= Build Report ==================="
echo "Compiled successfully : $compiled"
echo "Warnings             : $warnings"
echo "Errors               : $errors"
echo "Unsupported files    : $unsupported"

if [[ $warnings -gt 0 ]]; then
    echo "-> Warnings in:"
    for w in "${warning_files[@]}"; do
        echo "   - $w"
    done
fi

if [[ $errors -gt 0 ]]; then
    echo "-> Errors in:"
    for e in "${error_files[@]}"; do
        echo "   - $e"
    done
fi

if [[ $unsupported -gt 0 ]]; then
    echo "-> Unsupported files:"
    for u in "${unsupported_files[@]}"; do
        echo "   - $u"
    done
fi

echo "=================================================="
        	    </code></pre>
			</div>
			<br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
agora adicione as opcoes tamb√©m para java, rust, js e go.
no estilo:
rustc hello.rs -o hello
go build -o hello hello.go
o js, tu coloca shebang para node, mas o mesmo esquema de python, sempre verifique se ja nao tem um shebang.
javac HelloWorld.java -d bin, gerando .class mesmo
            </pre>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Cria pasta bin se n√£o existir
mkdir -p bin

# Verifica se quer modo info
INFO=false
while [[ "$1" == "--info" || "$1" == "-i" ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
    esac
    shift
done

compiled=0
warnings=0
errors=0
unsupported=0

warning_files=()
error_files=()
unsupported_files=()

# Controle de nomes ocupados
declare -A used_names

# Flag para "n√£o perguntar mais, usar name_ext automaticamente"
ASSUME_NO_ALL=false

echo "============== Compilation Started =============="

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        echo "[SKIP] File not found: $file"
        unsupported=$((unsupported + 1))
        unsupported_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"

    output_name="$name"

    # Verificar se o nome j√° est√° em uso
    if [[ -n "${used_names[$output_name]}" ]]; then
        echo "Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'."

        if $ASSUME_NO_ALL; then
            output_name="${name}_${ext}"
            echo "-> Automatically renaming '$filename' to bin/$output_name due to previous 'a' choice."
        else
            while true; do
                echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                read -n 1 -r choice
                echo
                if [[ "$choice" =~ ^[Yy]$ ]]; then
                    while true; do
                        read -p "Enter new name for '$filename': " newname
                        if [[ -z "$newname" ]]; then
                            echo "Name cannot be empty."
                            continue
                        fi
                        if [[ -n "${used_names[$newname]}" ]]; then
                            echo "Name 'bin/$newname' is already in use for '${used_names[$newname]}'."
                            continue
                        fi
                        output_name="$newname"
                        break
                    done
                    break
                elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                    output_name="${name}_${ext}"
                    break
                elif [[ "$choice" =~ ^[Aa]$ ]]; then
                    output_name="${name}_${ext}"
                    ASSUME_NO_ALL=true
                    echo "-> Automatically applying 'name_ext' for all next conflicts."
                    break
                else
                    echo "Please answer y, n or a."
                fi
            done
        fi
    fi

    # Registrar nome como usado
    used_names["$output_name"]="$filename"

    # Compila√ß√£o/Processamento
    case "$ext" in
        c)
            echo "[C   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx)
            echo "[C++ ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        py)
            echo "[PY  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "bin/$output_name"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env python3'; cat "$file"; } > "bin/$output_name"
            fi
            chmod +x "bin/$output_name"
            echo "[ OK ] bin/$output_name"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            echo "[JS  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*node' "$file"; then
                cp "$file" "bin/$output_name"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env node'; cat "$file"; } > "bin/$output_name"
            fi
            chmod +x "bin/$output_name"
            echo "[ OK ] bin/$output_name"
            compiled=$((compiled + 1))
            continue
            ;;
        rs)
            echo "[RUST] Compiling: $filename -> bin/$output_name"
            output=$(rustc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        go)
            echo "[GO  ] Compiling: $filename -> bin/$output_name"
            output=$(go build -o "bin/$output_name" "$file" 2>&1)
            status=$?
            ;;
        java)
            echo "[JAVA] Compiling: $filename -> bin/"
            output=$(javac -d bin "$file" 2>&1)
            status=$?

            if [[ $status -eq 0 ]]; then
                echo "[ OK ] bin/${name}.class"
                compiled=$((compiled + 1))
            else
                echo "[FAIL] Compilation failed: $filename"
                errors=$((errors + 1))
                error_files+=("$filename")
                $INFO && echo "$output"
            fi
            continue
            ;;
        *)
            echo "[SKIP] Unsupported extension: $filename"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            echo "[WARN] bin/$output_name compiled with warnings"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
            $INFO && echo "$output"
        else
            echo "[ OK ] bin/$output_name"
        fi
        compiled=$((compiled + 1))
    else
        echo "[FAIL] Compilation failed: $filename"
        errors=$((errors + 1))
        error_files+=("$filename")
        $INFO && echo "$output"
    fi

done

echo
echo "================= Build Report ==================="
echo "Compiled successfully : $compiled"
echo "Warnings             : $warnings"
echo "Errors               : $errors"
echo "Unsupported files    : $unsupported"

if [[ $warnings -gt 0 ]]; then
    echo "-> Warnings in:"
    for w in "${warning_files[@]}"; do
        echo "   - $w"
    done
fi

if [[ $errors -gt 0 ]]; then
    echo "-> Errors in:"
    for e in "${error_files[@]}"; do
        echo "   - $e"
    done
fi

if [[ $unsupported -gt 0 ]]; then
    echo "-> Unsupported files:"
    for u in "${unsupported_files[@]}"; do
        echo "   - $u"
    done
fi

echo "=================================================="
        		</code></pre>
			</div>

            <br>
			<h2>3. Toques finais e melhorias pr√°ticas</h2>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
adicione a funcionalidade de gerar um arquivo de log, se ele
ja existir nao o sobreponha, continue no final do arquivo. 
O arquvo de log deve ter o nome .vibeBuild.log, e nele deve
haver a data e hora de quando o comando foi rodado, o sistema,
usuario, nome do codigo fonte, diretorio atual, tipo de 
processamento, shebang, se foi copia (quando ja tem shebang), 
compilacao, etc, nome do arquivo gerado, diretorio de saida, 
se foi sucesso, se houve warning, se houve erro, warning e erro 
tem q estar no log, arquivos nao suportados, etc. se teve 
conflito, e a decisao tomada, o nome que foi alterado se a 
op√ß√£o for 'y', etc. deixe os output coloridos tamb√©m, por 
exemplo erro em vermelho, etc.
            </pre>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# === Colors ===
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# === Log File ===
LOG_FILE=".vibeBuild.log"

# === Create bin directory ===
mkdir -p bin

# === Parse flags ===
INFO=false
while [[ "$1" == "--info" || "$1" == "-i" ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
    esac
    shift
done

# === Stats ===
compiled=0
warnings=0
errors=0
unsupported=0

warning_files=()
error_files=()
unsupported_files=()

# === Used Names ===
declare -A used_names

# === Assume No All ===
ASSUME_NO_ALL=false

# === Start Log ===
{
    echo "========================="
    echo "Date: $(date)"
    echo "User: $(whoami)"
    echo "System: $(uname -a)"
    echo "Directory: $(pwd)"
    echo "========================="
} >> "$LOG_FILE"

echo -e "${BLUE}============== Compilation Started ==============${NC}"

# === Process Files ===
for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        echo -e "[${YELLOW}SKIP${NC}] File not found: $file"
        echo "[SKIP] File not found: $file" >> "$LOG_FILE"
        unsupported=$((unsupported + 1))
        unsupported_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"

    output_name="$name"

    # === Name conflict check ===
    if [[ -n "${used_names[$output_name]}" ]]; then
        echo -e "${YELLOW}Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'.${NC}"
        echo "Conflict: Name 'bin/$output_name' is already used for '${used_names[$output_name]}'." >> "$LOG_FILE"

        if $ASSUME_NO_ALL; then
            output_name="${name}_${ext}"
            echo "-> Auto renaming to bin/$output_name due to previous 'a' choice."
            echo "Decision: Auto rename to '$output_name' due to 'a' flag." >> "$LOG_FILE"
        else
            while true; do
                echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                read -n 1 -r choice
                echo
                if [[ "$choice" =~ ^[Yy]$ ]]; then
                    while true; do
                        read -p "Enter new name for '$filename': " newname
                        if [[ -z "$newname" ]]; then
                            echo "Name cannot be empty."
                            continue
                        fi
                        if [[ -n "${used_names[$newname]}" ]]; then
                            echo "Name 'bin/$newname' is already used for '${used_names[$newname]}'."
                            continue
                        fi
                        output_name="$newname"
                        echo "Decision: Manual rename to '$output_name'." >> "$LOG_FILE"
                        break
                    done
                    break
                elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                    output_name="${name}_${ext}"
                    echo "Decision: Auto rename to '$output_name'." >> "$LOG_FILE"
                    break
                elif [[ "$choice" =~ ^[Aa]$ ]]; then
                    output_name="${name}_${ext}"
                    ASSUME_NO_ALL=true
                    echo "Decision: Apply 'name_ext' for all next conflicts." >> "$LOG_FILE"
                    break
                else
                    echo "Please answer y, n or a."
                fi
            done
        fi
    fi

    used_names["$output_name"]="$filename"

    # === Compilation ===
    case "$ext" in
        c)
            echo -e "[${BLUE}C${NC}   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            type="C Compilation"
            ;;
        cpp|cc|cxx)
            echo -e "[${BLUE}C++${NC} ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "bin/$output_name" 2>&1)
            status=$?
            type="C++ Compilation"
            ;;
        rs)
            echo -e "[${BLUE}Rust${NC}] Compiling: $filename -> bin/$output_name"
            output=$(rustc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            type="Rust Compilation"
            ;;
        go)
            echo -e "[${BLUE}Go${NC}  ] Compiling: $filename -> bin/$output_name"
            output=$(go build -o "bin/$output_name" "$file" 2>&1)
            status=$?
            type="Go Compilation"
            ;;
        java)
            echo -e "[${BLUE}Java${NC}] Compiling: $filename -> bin/"
            output=$(javac "$file" -d bin 2>&1)
            status=$?
            output_name="${name}.class"
            type="Java Compilation"
            ;;
        py)
            echo -e "[${BLUE}PY${NC}  ] Processing: $filename -> bin/$output_name"
            type="Python Script"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "bin/$output_name"
                shebang="present"
                action="Copy"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env python3'; cat "$file"; } > "bin/$output_name"
                shebang="added"
                action="Shebang Added + Copy"
            fi
            chmod +x "bin/$output_name"
            echo -e "[${GREEN}OK${NC} ] bin/$output_name"
            echo "Processed: $filename -> bin/$output_name ($action)" >> "$LOG_FILE"
            echo "Type: $type | Shebang: $shebang | Status: OK" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            echo -e "[${BLUE}JS${NC}  ] Processing: $filename -> bin/$output_name"
            type="JavaScript Script"
            if grep -q '^#!.*node' "$file"; then
                cp "$file" "bin/$output_name"
                shebang="present"
                action="Copy"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env node'; cat "$file"; } > "bin/$output_name"
                shebang="added"
                action="Shebang Added + Copy"
            fi
            chmod +x "bin/$output_name"
            echo -e "[${GREEN}OK${NC} ] bin/$output_name"
            echo "Processed: $filename -> bin/$output_name ($action)" >> "$LOG_FILE"
            echo "Type: $type | Shebang: $shebang | Status: OK" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        *)
            echo -e "[${YELLOW}SKIP${NC}] Unsupported extension: $filename"
            echo "[SKIP] Unsupported extension: $filename" >> "$LOG_FILE"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    # === Handle Compilation Result ===
    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            echo -e "[${YELLOW}WARN${NC}] bin/$output_name compiled with warnings"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
            $INFO && echo "$output"
            echo "Type: $type | Status: WARN | Output: bin/$output_name" >> "$LOG_FILE"
            echo "Warnings:" >> "$LOG_FILE"
            echo "$output" >> "$LOG_FILE"
        else
            echo -e "[${GREEN}OK${NC} ] bin/$output_name"
            echo "Type: $type | Status: OK | Output: bin/$output_name" >> "$LOG_FILE"
        fi
        compiled=$((compiled + 1))
    else
        echo -e "[${RED}FAIL${NC}] Compilation failed: $filename"
        errors=$((errors + 1))
        error_files+=("$filename")
        $INFO && echo "$output"
        echo "Type: $type | Status: FAIL | File: $filename" >> "$LOG_FILE"
        echo "Errors:" >> "$LOG_FILE"
        echo "$output" >> "$LOG_FILE"
    fi
done

# === Build Report ===
echo
echo -e "${BLUE}================= Build Report ===================${NC}"
echo "Compiled successfully : $compiled"
echo "Warnings             : $warnings"
echo "Errors               : $errors"
echo "Unsupported files    : $unsupported"

if [[ $warnings -gt 0 ]]; then
    echo -e "-> ${YELLOW}Warnings in:${NC}"
    for w in "${warning_files[@]}"; do
        echo "   - $w"
    done
fi

if [[ $errors -gt 0 ]]; then
    echo -e "-> ${RED}Errors in:${NC}"
    for e in "${error_files[@]}"; do
        echo "   - $e"
    done
fi

if [[ $unsupported -gt 0 ]]; then
    echo "-> Unsupported files:"
    for u in "${unsupported_files[@]}"; do
        echo "   - $u"
    done
fi

echo -e "${BLUE}==================================================${NC}"
echo "==================================================" >> "$LOG_FILE"
        		</code></pre>
<img src="https://i.ibb.co/jv8pXV4y/s8.png" alt="VibeBuild output">
			</div>
            <br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
adicione um --quiet, um --help, e toda vez que
rodar o codigo, pergunte se tem certeza de excluir
todo o conteudo de bin/ e excluir tudo de bin/ 
antes de compilar os c√≥digos. deve possuir -q e
-h como alternativas respectivamente. Se n√£o 
houver input file, n√£o limpe bin/. Al√©m disso,
caso n√£o houver o arquivo de entrada, mostre na 
sa√≠da que o arquivo n√£o foi encontrado, pois est√° 
sendo mostrado como unsuported file, mesmo que ele 
nem exista. Tamb√©m corrija um pequeno problema, 
quando houver erro, deixe em vermelho, n√£o somente
em --run, como no relatorio tamb√©m.
            </pre>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# ========== Configura√ß√µes iniciais ==========
BIN_DIR="bin"
LOG_FILE=".vibeBuild.log"
mkdir -p "$BIN_DIR"

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # Reset

# ========== Op√ß√µes ==========
INFO=false
QUIET=false
RUN=false

# Processa flags
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
        --quiet|-q) QUIET=true ;;
        --run|-r) RUN=true ;;
        --help|-h)
            echo -e "${BLUE}Usage:${NC} ./vibeBuild [options] [files]"
            echo "Options:"
            echo "  --info,  -i   Show compiler warnings and errors"
            echo "  --quiet, -q   Minimal output"
            echo "  --run,   -r   Compile (if needed) and run the code"
            echo "  --help,  -h   Show this help"
            exit 0
            ;;
        *) break ;;
    esac
    shift
done

# ========== Pergunta se deve limpar ==========
if [[ $# -gt 0 && $RUN == false ]]; then
    read -p "Do you want to clean '$BIN_DIR/' before building? (y/N) " choice
    if [[ "$choice" =~ ^[Yy]$ ]]; then
        rm -rf "$BIN_DIR"/*
        echo "Cleaned '$BIN_DIR/'"
    fi
fi

# ========== Inicializa contadores ==========
compiled=0
warnings=0
errors=0
unsupported=0
notfound=0

warning_files=()
error_files=()
unsupported_files=()
notfound_files=()

declare -A used_names
ASSUME_NO_ALL=false

# ========== Inicia log ==========
{
echo
echo "========== Build Started =========="
echo "Date: $(date)"
echo "User: $USER"
echo "System: $(uname -a)"
echo "Directory: $(pwd)"
} >> "$LOG_FILE"

# ========== Come√ßa compila√ß√£o ou execu√ß√£o ==========
$QUIET || echo -e "${BLUE}============== Process Started ==============${NC}"

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        $QUIET || echo -e "${YELLOW}[NOT FOUND] File not found: $file${NC}"
        echo "[NOT FOUND] File not found: $file" >> "$LOG_FILE"
        notfound=$((notfound + 1))
        notfound_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"
    output_name="$name"

    # Para --run n√£o precisa tratar conflito de nomes
    if [[ "$RUN" == false ]]; then
        if [[ -n "${used_names[$output_name]}" ]]; then
            $QUIET || echo -e "${YELLOW}Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'${NC}"
            echo "[CONFLICT] bin/$output_name already used by ${used_names[$output_name]}" >> "$LOG_FILE"

            if $ASSUME_NO_ALL; then
                output_name="${name}_${ext}"
                $QUIET || echo "-> Automatically renaming '$filename' to bin/$output_name"
                echo "[RESOLVE] Auto rename to $output_name (previous A choice)" >> "$LOG_FILE"
            else
                while true; do
                    echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                    read -n 1 -r choice
                    echo
                    if [[ "$choice" =~ ^[Yy]$ ]]; then
                        while true; do
                            read -p "Enter new name: " newname
                            if [[ -z "$newname" ]]; then
                                echo "Name cannot be empty."
                                continue
                            fi
                            if [[ -n "${used_names[$newname]}" ]]; then
                                echo "Name 'bin/$newname' already used."
                                continue
                            fi
                            output_name="$newname"
                            echo "[RESOLVE] Manual rename to $output_name" >> "$LOG_FILE"
                            break
                        done
                        break
                    elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                        output_name="${name}_${ext}"
                        echo "[RESOLVE] Auto rename to $output_name" >> "$LOG_FILE"
                        break
                    elif [[ "$choice" =~ ^[Aa]$ ]]; then
                        output_name="${name}_${ext}"
                        ASSUME_NO_ALL=true
                        echo "-> Automatically applying 'name_ext' for next conflicts."
                        echo "[RESOLVE] Auto rename to $output_name (A selected)" >> "$LOG_FILE"
                        break
                    else
                        echo "Please answer y, n or a."
                    fi
                done
            fi
        fi
        used_names["$output_name"]="$filename"
    fi

    # ========== RUN ==========
    if [[ "$RUN" == true ]]; then
        tmpfile="/tmp/vibe_tmp_$(date +%s%N)_$RANDOM"
        trap "rm -f $tmpfile; exit" INT TERM

        case "$ext" in
            py)
                $QUIET || echo "[PY  ] Running: $filename"
                if grep -q '^#!.*python' "$file"; then
                    "$file"
                else
                    python3 "$file"
                fi
                ;;
            js)
                $QUIET || echo "[JS  ] Running: $filename"
                if grep -q '^#!.*node' "$file"; then
                    "$file"
                else
                    node "$file"
                fi
                ;;
            c)
                $QUIET || echo "[C   ] Compiling & Running: $filename"
                gcc "$file" -o "$tmpfile"
                if [[ $? -eq 0 ]]; then
                    "$tmpfile"
                else
                    echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
                fi
                ;;
            cpp|cc|cxx|c++)
                $QUIET || echo "[C++ ] Compiling & Running: $filename"
                g++ "$file" -o "$tmpfile"
                if [[ $? -eq 0 ]]; then
                    "$tmpfile"
                else
                    echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
                fi
                ;;
            rs)
                $QUIET || echo "[RS  ] Compiling & Running: $filename"
                rustc "$file" -o "$tmpfile"
                if [[ $? -eq 0 ]]; then
                    "$tmpfile"
                else
                    echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
                fi
                ;;
            go)
                $QUIET || echo "[GO  ] Compiling & Running: $filename"
                go build -o "$tmpfile" "$file"
                if [[ $? -eq 0 ]]; then
                    "$tmpfile"
                else
                    echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
                fi
                ;;
            java)
                $QUIET || echo "[JAVA] Compiling & Running: $filename"
                class_name=$(basename "$file" .java)
                javac "$file" -d /tmp
                if [[ $? -eq 0 ]]; then
                    java -cp /tmp "$class_name"
                    rm -f "/tmp/$class_name.class"
                else
                    echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
                fi
                ;;
            *)
                $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension for run: $filename${NC}"
                ;;
        esac

        rm -f "$tmpfile"
        continue
    fi

    # ========== BUILD NORMAL ==========
    case "$ext" in
        c)
            $QUIET || echo "[C   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx|c++)
            $QUIET || echo "[C++ ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        py)
            $QUIET || echo "[PY  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang="(has shebang)"
            else
                echo '#!/usr/bin/env python3' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang="(added shebang)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[PY] $filename -> bin/$output_name $shebang" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            $QUIET || echo "[JS  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*node' "$file"; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang="(has shebang)"
            else
                echo '#!/usr/bin/env node' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang="(added shebang)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[JS] $filename -> bin/$output_name $shebang" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        rs)
            $QUIET || echo "[RS  ] Compiling: $filename -> bin/$output_name"
            output=$(rustc "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        go)
            $QUIET || echo "[GO  ] Compiling: $filename -> bin/$output_name"
            output=$(go build -o "$BIN_DIR/$output_name" "$file" 2>&1)
            status=$?
            ;;
        java)
            $QUIET || echo "[JAVA] Compiling: $filename -> bin/"
            output=$(javac "$file" -d "$BIN_DIR" 2>&1)
            status=$?
            output_name="$name.class"
            ;;
        *)
            $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension: $filename${NC}"
            echo "[SKIP] Unsupported: $filename" >> "$LOG_FILE"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    # ========== Avalia√ß√£o ==========
    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            $QUIET || echo -e "${YELLOW}[WARN] bin/$output_name compiled with warnings${NC}"
            echo "[WARN] bin/$output_name" >> "$LOG_FILE"
            $INFO && echo "$output"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
        else
            $QUIET || echo -e "${GREEN}[ OK ] bin/$output_name${NC}"
            echo "[OK] bin/$output_name" >> "$LOG_FILE"
        fi
        compiled=$((compiled + 1))
    else
        $QUIET || echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
        echo "[FAIL] $filename" >> "$LOG_FILE"
        $INFO && echo "$output"
        errors=$((errors + 1))
        error_files+=("$filename")
    fi

done

# ========== Relat√≥rio ==========
if [[ "$RUN" == false ]]; then
    echo
    echo -e "${BLUE}================= Build Report ===================${NC}"
    echo -e "Compiled successfully : ${GREEN}$compiled${NC}"
    echo -e "Warnings              : ${YELLOW}$warnings${NC}"
    echo -e "Errors                : ${RED}$errors${NC}"
    echo -e "Unsupported files     : ${YELLOW}$unsupported${NC}"
    echo -e "Not found files       : ${YELLOW}$notfound${NC}"

    if [[ $warnings -gt 0 ]]; then
        echo -e "${YELLOW}-> Warnings in:${NC}"
        for w in "${warning_files[@]}"; do
            echo "   - $w"
        done
    fi
    if [[ $errors -gt 0 ]]; then
        echo -e "${RED}-> Errors in:${NC}"
        for e in "${error_files[@]}"; do
            echo "   - $e"
        done
    fi
    if [[ $unsupported -gt 0 ]]; then
        echo -e "${YELLOW}-> Unsupported files:${NC}"
        for u in "${unsupported_files[@]}"; do
            echo "   - $u"
        done
    fi
    if [[ $notfound -gt 0 ]]; then
        echo -e "${YELLOW}-> Not found files:${NC}"
        for n in "${notfound_files[@]}"; do
            echo "   - $n"
        done
    fi
    echo -e "${BLUE}==================================================${NC}"
    echo "========== Build Finished ==========" >> "$LOG_FILE"
fi
                </code></pre>
<img src="https://i.ibb.co/ycQ1D7ZS/s9.png" alt="VibeBuild output">
			</div>
            <br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
quando o comando for chamado sem par√¢metro algum, 
deve-se chamar o --help. No help adicione a seguinte
logo:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      O       Idealized By:       Programmed By  ‚îÇ
‚îÇ     _|_   Renato L√≥is M. Silva     ChatGPT4o    ‚îÇ
‚îÇ    /   \  Luiz Eduardo G. Cidade                ‚îÇ
‚îÇ    () ()  Davi Eduardo S. de Lima               ‚îÇ
‚îÇ   ,|_ _|,                                       ‚îÇ
‚îÇ _/_______\_ ....          VibeBuild             ‚îÇ
‚îÇ \  < / >  / |--|)                               ‚îÇ
‚îÇ  \_______/  |__|  One script to build them all  ‚îÇ 
‚îÇ                                                 ‚îÇ
‚îÇ           https://vibebuild.github.io/          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            </pre>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# ========== Configura√ß√µes iniciais ==========
BIN_DIR="bin"
LOG_FILE=".vibeBuild.log"
mkdir -p "$BIN_DIR"

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # Reset

# ========== Op√ß√µes ==========
INFO=false
QUIET=false
RUN=false

# Se nenhum par√¢metro for passado, mostra o help
if [[ $# -eq 0 ]]; then
    set -- --help
fi

# Processa flags
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
        --quiet|-q) QUIET=true ;;
        --run|-r) RUN=true ;;
        --help|-h)
            echo -e "${BLUE}"
            cat << "EOF"
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      O       Idealized By:       Programmed By  ‚îÇ
‚îÇ     _|_   Renato L√≥is M. Silva     ChatGPT4o    ‚îÇ
‚îÇ    /   \  Luiz Eduardo G. Cidade                ‚îÇ
‚îÇ    () ()  Davi Eduardo S. de Lima               ‚îÇ
‚îÇ   ,|_ _|,                                       ‚îÇ
‚îÇ _/_______\_ ....          VibeBuild             ‚îÇ
‚îÇ \  < / >  / |--|)                               ‚îÇ
‚îÇ  \_______/  |__|  One script to build them all  ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ           https://vibebuild.github.io/          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
EOF
            echo -e "${NC}"
            echo -e "${BLUE}Usage:${NC} ./vibeBuild [options] [files]"
            echo "Options:"
            echo "  --info,  -i   Show compiler warnings and errors"
            echo "  --quiet, -q   Minimal output"
            echo "  --run,   -r   Compile (if needed) and run the code"
            echo "  --help,  -h   Show this help"
            exit 0
            ;;
        *) break ;;
    esac
    shift
done

# ========== Pergunta se deve limpar ==========
if [[ $# -gt 0 && $RUN == false ]]; then
    read -p "Do you want to clean '$BIN_DIR/' before building? (y/N) " choice
    if [[ "$choice" =~ ^[Yy]$ ]]; then
        rm -rf "$BIN_DIR"/*
        echo "Cleaned '$BIN_DIR/'"
    fi
fi

# ========== Inicializa contadores ==========
compiled=0
warnings=0
errors=0
unsupported=0
notfound=0

warning_files=()
error_files=()
unsupported_files=()
error_files=()
notfound_files=()

declare -A used_names
ASSUME_NO_ALL=false

# ========== Inicia log ==========
{
echo
echo "========== Build Started =========="
echo "Date: $(date)"
echo "User: $USER"
echo "System: $(uname -a)"
echo "Directory: $(pwd)"
} >> "$LOG_FILE"

# ========== Come√ßa compila√ß√£o ou execu√ß√£o ==========
$QUIET || echo -e "${BLUE}============== Process Started ==============${NC}"

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        $QUIET || echo -e "${RED}[NOT FOUND] File not found: $file${NC}"
        echo "[NOT FOUND] File not found: $file" >> "$LOG_FILE"
        notfound=$((notfound + 1))
        notfound_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"
    output_name="$name"

    if [[ "$RUN" == false ]]; then
        if [[ -n "${used_names[$output_name]}" ]]; then
            $QUIET || echo -e "${YELLOW}Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'${NC}"
            echo "[CONFLICT] bin/$output_name already used by ${used_names[$output_name]}" >> "$LOG_FILE"

            if $ASSUME_NO_ALL; then
                output_name="${name}_${ext}"
                $QUIET || echo "-> Automatically renaming '$filename' to bin/$output_name"
                echo "[RESOLVE] Auto rename to $output_name (previous A choice)" >> "$LOG_FILE"
            else
                while true; do
                    echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                    read -n 1 -r choice
                    echo
                    if [[ "$choice" =~ ^[Yy]$ ]]; then
                        while true; do
                            read -p "Enter new name: " newname
                            if [[ -z "$newname" ]]; then
                                echo "Name cannot be empty."
                                continue
                            fi
                            if [[ -n "${used_names[$newname]}" ]]; then
                                echo "Name 'bin/$newname' already used."
                                continue
                            fi
                            output_name="$newname"
                            echo "[RESOLVE] Manual rename to $output_name" >> "$LOG_FILE"
                            break
                        done
                        break
                    elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                        output_name="${name}_${ext}"
                        echo "[RESOLVE] Auto rename to $output_name" >> "$LOG_FILE"
                        break
                    elif [[ "$choice" =~ ^[Aa]$ ]]; then
                        output_name="${name}_${ext}"
                        ASSUME_NO_ALL=true
                        echo "-> Automatically applying 'name_ext' for next conflicts."
                        echo "[RESOLVE] Auto rename to $output_name (A selected)" >> "$LOG_FILE"
                        break
                    else
                        echo "Please answer y, n or a."
                    fi
                done
            fi
        fi
        used_names["$output_name"]="$filename"
    fi

    # ========== RUN ==========
    if [[ "$RUN" == true ]]; then
        tmpfile="/tmp/vibe_tmp_$(date +%s%N)_$RANDOM"
        trap "rm -f $tmpfile; exit" INT TERM

        case "$ext" in
            py)
                $QUIET || echo "[PY  ] Running: $filename"
                if grep -q '^#!.*python' "$file"; then
                    "$file"
                else
                    python3 "$file"
                fi
                ;;
            js)
                $QUIET || echo "[JS  ] Running: $filename"
                if grep -q '^#!.*node' "$file"; then
                    "$file"
                else
                    node "$file"
                fi
                ;;
            c)
                $QUIET || echo "[C   ] Compiling & Running: $filename"
                gcc "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            cpp|cc|cxx|c++)
                $QUIET || echo "[C++ ] Compiling & Running: $filename"
                g++ "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            rs)
                $QUIET || echo "[RS  ] Compiling & Running: $filename"
                rustc "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            go)
                $QUIET || echo "[GO  ] Compiling & Running: $filename"
                go build -o "$tmpfile" "$file" && "$tmpfile"
                ;;
            java)
                $QUIET || echo "[JAVA] Compiling & Running: $filename"
                class_name=$(basename "$file" .java)
                javac "$file" -d /tmp && java -cp /tmp "$class_name"
                rm -f "/tmp/$class_name.class"
                ;;
            *)
                $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension for run: $filename${NC}"
                ;;
        esac

        rm -f "$tmpfile"
        continue
    fi

    # ========== BUILD ==========
    case "$ext" in
        c)
            $QUIET || echo "[C   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx|c++)
            $QUIET || echo "[C++ ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        py)
            $QUIET || echo "[PY  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang="(has shebang)"
            else
                echo '#!/usr/bin/env python3' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang="(added shebang)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[PY] $filename -> bin/$output_name $shebang" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            $QUIET || echo "[JS  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*node' "$file"; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang="(has shebang)"
            else
                echo '#!/usr/bin/env node' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang="(added shebang)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[JS] $filename -> bin/$output_name $shebang" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        rs)
            $QUIET || echo "[RS  ] Compiling: $filename -> bin/$output_name"
            output=$(rustc "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        go)
            $QUIET || echo "[GO  ] Compiling: $filename -> bin/$output_name"
            output=$(go build -o "$BIN_DIR/$output_name" "$file" 2>&1)
            status=$?
            ;;
        java)
            $QUIET || echo "[JAVA] Compiling: $filename -> bin/"
            output=$(javac "$file" -d "$BIN_DIR" 2>&1)
            status=$?
            output_name="$name.class"
            ;;
        *)
            $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension: $filename${NC}"
            echo "[SKIP] Unsupported: $filename" >> "$LOG_FILE"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    # ========== Avalia√ß√£o ==========
    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            $QUIET || echo -e "${YELLOW}[WARN] bin/$output_name compiled with warnings${NC}"
            echo "[WARN] bin/$output_name" >> "$LOG_FILE"
            $INFO && echo "$output"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
        else
            $QUIET || echo -e "${GREEN}[ OK ] bin/$output_name${NC}"
            echo "[OK] bin/$output_name" >> "$LOG_FILE"
        fi
        compiled=$((compiled + 1))
    else
        $QUIET || echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
        echo "[FAIL] $filename" >> "$LOG_FILE"
        $INFO && echo "$output"
        errors=$((errors + 1))
        error_files+=("$filename")
    fi

done

# ========== Relat√≥rio ==========
if [[ "$RUN" == false ]]; then
    echo
    echo -e "${BLUE}================= Build Report ===================${NC}"
    echo "Compiled successfully : $compiled"
    echo "Warnings              : $warnings"
    echo -e "Errors                : ${RED}$errors${NC}"
    echo "Unsupported files     : $unsupported"
    echo "Not found files       : $notfound"

    if [[ $warnings -gt 0 ]]; then
        echo "-> Warnings in:"
        for w in "${warning_files[@]}"; do
            echo "   - $w"
        done
    fi
    if [[ $errors -gt 0 ]]; then
        echo "-> Errors in:"
        for e in "${error_files[@]}"; do
            echo "   - $e"
        done
    fi
    if [[ $unsupported -gt 0 ]]; then
        echo "-> Unsupported files:"
        for u in "${unsupported_files[@]}"; do
            echo "   - $u"
        done
    fi
    if [[ $notfound -gt 0 ]]; then
        echo "-> Not found files:"
        for n in "${notfound_files[@]}"; do
            echo "   - $n"
        done
    fi
    echo -e "${BLUE}==================================================${NC}"
    echo "========== Build Finished ==========" >> "$LOG_FILE"
fi
        		</code></pre>
			</div>
            
            <br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
por √∫ltimo, consiga receber a op√ß√£o --clang para usar
lang em vez de gnu c compiler. nos logs especifique
o tipo de shebang que sera inserido, ou se ja existe, 
mostre o ja existente, e mostre o compilador ou 
interpretador usado no momento, com seu caminho completo.
envie o codigo apos essas altera√ß√µes.</pre>
			<p><strong>Vers√£o desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# ========== Configura√ß√µes iniciais ==========
BIN_DIR="bin"
LOG_FILE=".vibeBuild.log"
mkdir -p "$BIN_DIR"

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# ========== Op√ß√µes ==========
INFO=false
QUIET=false
RUN=false
USE_CLANG=false

# Se nenhum par√¢metro for passado, mostra o help
if [[ $# -eq 0 ]]; then
    set -- --help
fi

# Processa flags
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
        --quiet|-q) QUIET=true ;;
        --run|-r) RUN=true ;;
        --clang) USE_CLANG=true ;;
        --help|-h)
            echo -e "${BLUE}"
            cat << "EOF"
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      O       Idealized By:       Programmed By  ‚îÇ
‚îÇ     _|_   Renato L√≥is M. Silva     ChatGPT4o    ‚îÇ
‚îÇ    /   \  Luiz Eduardo G. Cidade                ‚îÇ
‚îÇ    () ()  Davi Eduardo S. de Lima               ‚îÇ
‚îÇ   ,|_ _|,                                       ‚îÇ
‚îÇ _/_______\_ ....          VibeBuild             ‚îÇ
‚îÇ \  < / >  / |--|)                               ‚îÇ
‚îÇ  \_______/  |__|  One script to build them all  ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ           https://vibebuild.github.io/          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
EOF
            echo -e "${NC}"
            echo -e "${BLUE}Usage:${NC} ./vibeBuild [options] [files]"
            echo "Options:"
            echo "  --info,  -i   Show compiler warnings and errors"
            echo "  --quiet, -q   Minimal output"
            echo "  --run,   -r   Compile (if needed) and run the code"
            echo "  --clang       Use clang/clang++ instead of gcc/g++"
            echo "  --help,  -h   Show this help"
            exit 0
            ;;
        *) break ;;
    esac
    shift
done

# Configura compiladores
CC=$(command -v gcc)
CXX=$(command -v g++)
if $USE_CLANG; then
    CC=$(command -v clang)
    CXX=$(command -v clang++)
fi

# ========== Pergunta se deve limpar ==========
if [[ $# -gt 0 && $RUN == false ]]; then
    read -p "Do you want to clean '$BIN_DIR/' before building? (y/N) " choice
    if [[ "$choice" =~ ^[Yy]$ ]]; then
        rm -rf "$BIN_DIR"/*
        echo "Cleaned '$BIN_DIR/'"
    fi
fi

# ========== Inicializa contadores ==========
compiled=0
warnings=0
errors=0
unsupported=0
notfound=0

warning_files=()
error_files=()
unsupported_files=()
notfound_files=()

declare -A used_names
ASSUME_NO_ALL=false

# ========== Inicia log ==========
{
echo
echo "========== Build Started =========="
echo "Date: $(date)"
echo "User: $USER"
echo "System: $(uname -a)"
echo "Directory: $(pwd)"
echo "C Compiler: $CC"
echo "C++ Compiler: $CXX"
echo "Python: $(command -v python3)"
echo "Node.js: $(command -v node)"
echo "Rust: $(command -v rustc)"
echo "Go: $(command -v go)"
echo "Java: $(command -v javac) / $(command -v java)"
} >> "$LOG_FILE"

# ========== Come√ßa compila√ß√£o ou execu√ß√£o ==========
$QUIET || echo -e "${BLUE}============== Process Started ==============${NC}"

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        $QUIET || echo -e "${RED}[NOT FOUND] File not found: $file${NC}"
        echo "[NOT FOUND] File not found: $file" >> "$LOG_FILE"
        notfound=$((notfound + 1))
        notfound_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"
    output_name="$name"

    if [[ "$RUN" == false ]]; then
        if [[ -n "${used_names[$output_name]}" ]]; then
            $QUIET || echo -e "${YELLOW}Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'${NC}"
            echo "[CONFLICT] bin/$output_name already used by ${used_names[$output_name]}" >> "$LOG_FILE"

            if $ASSUME_NO_ALL; then
                output_name="${name}_${ext}"
                $QUIET || echo "-> Automatically renaming '$filename' to bin/$output_name"
                echo "[RESOLVE] Auto rename to $output_name (previous A choice)" >> "$LOG_FILE"
            else
                while true; do
                    echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                    read -n 1 -r choice
                    echo
                    if [[ "$choice" =~ ^[Yy]$ ]]; then
                        while true; do
                            read -p "Enter new name: " newname
                            if [[ -z "$newname" ]]; then
                                echo "Name cannot be empty."
                                continue
                            fi
                            if [[ -n "${used_names[$newname]}" ]]; then
                                echo "Name 'bin/$newname' already used."
                                continue
                            fi
                            output_name="$newname"
                            echo "[RESOLVE] Manual rename to $output_name" >> "$LOG_FILE"
                            break
                        done
                        break
                    elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                        output_name="${name}_${ext}"
                        echo "[RESOLVE] Auto rename to $output_name" >> "$LOG_FILE"
                        break
                    elif [[ "$choice" =~ ^[Aa]$ ]]; then
                        output_name="${name}_${ext}"
                        ASSUME_NO_ALL=true
                        echo "-> Automatically applying 'name_ext' for next conflicts."
                        echo "[RESOLVE] Auto rename to $output_name (A selected)" >> "$LOG_FILE"
                        break
                    else
                        echo "Please answer y, n or a."
                    fi
                done
            fi
        fi
        used_names["$output_name"]="$filename"
    fi

    # ========== RUN ==========
    if [[ "$RUN" == true ]]; then
        tmpfile="/tmp/vibe_tmp_$(date +%s%N)_$RANDOM"
        trap "rm -f $tmpfile; exit" INT TERM

        case "$ext" in
            py)
                interp=$(command -v python3)
                $QUIET || echo "[PY  ] Running: $filename ($interp)"
                if grep -q '^#!.*python' "$file"; then
                    "$file"
                else
                    "$interp" "$file"
                fi
                ;;
            js)
                interp=$(command -v node)
                $QUIET || echo "[JS  ] Running: $filename ($interp)"
                if grep -q '^#!.*node' "$file"; then
                    "$file"
                else
                    "$interp" "$file"
                fi
                ;;
            c)
                $QUIET || echo "[C   ] Compiling & Running: $filename ($CC)"
                "$CC" "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            cpp|cc|cxx|c++)
                $QUIET || echo "[C++ ] Compiling & Running: $filename ($CXX)"
                "$CXX" "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            rs)
                rustc_path=$(command -v rustc)
                $QUIET || echo "[RS  ] Compiling & Running: $filename ($rustc_path)"
                rustc "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            go)
                go_path=$(command -v go)
                $QUIET || echo "[GO  ] Compiling & Running: $filename ($go_path)"
                go build -o "$tmpfile" "$file" && "$tmpfile"
                ;;
            java)
                javac_path=$(command -v javac)
                java_path=$(command -v java)
                class_name=$(basename "$file" .java)
                $QUIET || echo "[JAVA] Compiling & Running: $filename ($javac_path/$java_path)"
                javac "$file" -d /tmp && java -cp /tmp "$class_name"
                rm -f "/tmp/$class_name.class"
                ;;
            *)
                $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension for run: $filename${NC}"
                ;;
        esac

        rm -f "$tmpfile"
        continue
    fi

    # ========== BUILD ==========
    case "$ext" in
        c)
            $QUIET || echo "[C   ] Compiling: $filename -> bin/$output_name ($CC)"
            output=$("$CC" "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx|c++)
            $QUIET || echo "[C++ ] Compiling: $filename -> bin/$output_name ($CXX)"
            output=$("$CXX" "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        py)
            interp=$(command -v python3)
            shebang=$(grep -m1 '^#!' "$file")
            if [[ -n "$shebang" ]]; then
                info="(has shebang: $shebang)"
            else
                echo '#!/usr/bin/env python3' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                info="(added shebang: #!/usr/bin/env python3)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[PY] $filename -> bin/$output_name $info (interpreter: $interp)" >> "$LOG_FILE"
            $QUIET || echo "[PY  ] $filename -> bin/$output_name $info ($interp)"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            interp=$(command -v node)
            shebang=$(grep -m1 '^#!' "$file")
            if [[ -n "$shebang" ]]; then
                info="(has shebang: $shebang)"
            else
                echo '#!/usr/bin/env node' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                info="(added shebang: #!/usr/bin/env node)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[JS] $filename -> bin/$output_name $info (interpreter: $interp)" >> "$LOG_FILE"
            $QUIET || echo "[JS  ] $filename -> bin/$output_name $info ($interp)"
            compiled=$((compiled + 1))
            continue
            ;;
        rs)
            rustc_path=$(command -v rustc)
            $QUIET || echo "[RS  ] Compiling: $filename -> bin/$output_name ($rustc_path)"
            output=$(rustc "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        go)
            go_path=$(command -v go)
            $QUIET || echo "[GO  ] Compiling: $filename -> bin/$output_name ($go_path)"
            output=$(go build -o "$BIN_DIR/$output_name" "$file" 2>&1)
            status=$?
            ;;
        java)
            javac_path=$(command -v javac)
            $QUIET || echo "[JAVA] Compiling: $filename -> bin/ ($javac_path)"
            output=$(javac "$file" -d "$BIN_DIR" 2>&1)
            status=$?
            output_name="$name.class"
            ;;
        *)
            $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension: $filename${NC}"
            echo "[SKIP] Unsupported: $filename" >> "$LOG_FILE"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    # ========== Avalia√ß√£o ==========
    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            $QUIET || echo -e "${YELLOW}[WARN] bin/$output_name compiled with warnings${NC}"
            echo "[WARN] bin/$output_name" >> "$LOG_FILE"
            $INFO && echo "$output"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
        else
            $QUIET || echo -e "${GREEN}[ OK ] bin/$output_name${NC}"
            echo "[OK] bin/$output_name" >> "$LOG_FILE"
        fi
        compiled=$((compiled + 1))
    else
        $QUIET || echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
        echo "[FAIL] $filename" >> "$LOG_FILE"
        $INFO && echo "$output"
        errors=$((errors + 1))
        error_files+=("$filename")
    fi

done

# ========== Relat√≥rio ==========
if [[ "$RUN" == false ]]; then
    echo
    echo -e "${BLUE}================= Build Report ===================${NC}"
    echo "Compiled successfully : $compiled"
    echo "Warnings              : $warnings"
    echo -e "Errors                : ${RED}$errors${NC}"
    echo "Unsupported files     : $unsupported"
    echo "Not found files       : $notfound"

    if [[ $warnings -gt 0 ]]; then
        echo "-> Warnings in:"
        for w in "${warning_files[@]}"; do
            echo "   - $w"
        done
    fi
    if [[ $errors -gt 0 ]]; then
        echo "-> Errors in:"
        for e in "${error_files[@]}"; do
            echo "   - $e"
        done
    fi
    if [[ $unsupported -gt 0 ]]; then
        echo "-> Unsupported files:"
        for u in "${unsupported_files[@]}"; do
            echo "   - $u"
        done
    fi
    if [[ $notfound -gt 0 ]]; then
        echo "-> Not found files:"
        for n in "${notfound_files[@]}"; do
            echo "   - $n"
        done
    fi
    echo -e "${BLUE}==================================================${NC}"
    echo "========== Build Finished ==========" >> "$LOG_FILE"
fi
        		</code></pre>
			</div>
		<div class="sub-info">
					<p>Aqui percebi um erro. em arquivos que √© necess√°rio um shebang para tornalo execut√°vel, h√° o erro em que o chmod n√£o encontra o execut√°vel, pois ainda nao foi gerado em /bin. A IA corrigir√° isso no pr√≥ximo prompt.
					</p>
				</div>
            <br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
============== Process Started ==============
[C++ ] Compiling: cpp1.cpp -> bin/cpp1 (/sbin/clang++)
[ OK ] bin/cpp1
chmod: cannot access 'bin/b': No such file or directory
[PY  ] b.py -> bin/b (has shebang: #!/usr/bin/python3) (/sbin/python3)
Name 'bin/b' is already in use for 'b.py'
Do you want to enter a custom name for 'b.c'? (y/N/a) a
-> Automatically applying 'name_ext' for next conflicts.
[C   ] Compiling: b.c -> bin/b_c (/sbin/clang)
[ OK ] bin/b_c
Name 'bin/b' is already in use for 'b.py'

esse trecho do output mostra um erro, o chmod n√£o consegue
acessar o execut√°vel. corrija-o.
al√©m disso, adicione a op√ß√£o --dest, ou -d, para definir o destino
do bin√°rio. Caso nao for especificado o diret√≥rio, envie para 
a pasta atual. Por exemplo: vibe codigo.c -d, o bin√°rio deve ser 
gerado no diret√≥rio atual. Pergunte se quer limpar o diret√≥rio 
especificado caso n√£o seja o atual. E Adicione a opcao -y e -n para 
nao perguntar se quer limpar ou nao a pasta bin e tamb√©m adicione 
isto ao --help.
            </pre>
			<p><strong>Vers√£o desenvolvida (Final):</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# ========== Configura√ß√µes iniciais ==========
BIN_DIR="bin"
LOG_FILE=".vibeBuild.log"
mkdir -p "$BIN_DIR"

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # Reset

# ========== Op√ß√µes ==========
INFO=false
QUIET=false
RUN=false
USE_CLANG=false
DEST_SET=false
FORCE_CLEAN=""
ASSUME_NO_ALL=false

# Se nenhum par√¢metro for passado, mostra o help
if [[ $# -eq 0 ]]; then
    set -- --help
fi

# Processa flags
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
        --quiet|-q) QUIET=true ;;
        --run|-r) RUN=true ;;
        --clang) USE_CLANG=true ;;
        --dest|-d)
            DEST_SET=true
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                BIN_DIR="$2"
                shift
            else
                BIN_DIR="."
            fi
            ;;
        -y) FORCE_CLEAN="yes" ;;
        -n) FORCE_CLEAN="no" ;;
        --help|-h)
            echo -e "${BLUE}"
            cat << "EOF"
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      O       Idealized By:       Programmed By  ‚îÇ
‚îÇ     _|_   Renato L√≥is M. Silva     ChatGPT4o    ‚îÇ
‚îÇ    /   \  Luiz Eduardo G. Cidade                ‚îÇ
‚îÇ    () ()  Davi Eduardo S. de Lima               ‚îÇ
‚îÇ   ,|_ _|,                                       ‚îÇ
‚îÇ _/_______\_ ....          VibeBuild             ‚îÇ
‚îÇ \  < / >  / |--|)                               ‚îÇ
‚îÇ  \_______/  |__|  One script to build them all  ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ           https://vibebuild.github.io/          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
EOF
            echo -e "${NC}"
            echo -e "${BLUE}Usage:${NC} ./vibeBuild [options] [files]"
            echo "Options:"
            echo "  --info,  -i   Show compiler warnings and errors"
            echo "  --quiet, -q   Minimal output"
            echo "  --run,   -r   Compile (if needed) and run the code"
            echo "  --clang       Use clang/clang++ instead of gcc/g++"
            echo "  --dest,  -d   Set output directory (default: bin)"
            echo "  -y            Always clean bin/ before building (no prompt)"
            echo "  -n            Never clean bin/ (no prompt)"
            echo "  --help,  -h   Show this help"
            exit 0
            ;;
        *) break ;;
    esac
    shift
done

# Cria o diret√≥rio de destino se n√£o existir
mkdir -p "$BIN_DIR"

# ========== Pergunta se deve limpar ==========
if [[ $# -gt 0 && $RUN == false && $BIN_DIR == "bin" ]]; then
    if [[ "$FORCE_CLEAN" == "yes" ]]; then
        rm -rf "bin"/*
        echo "Cleaned 'bin/' (forced)"
    elif [[ "$FORCE_CLEAN" == "no" ]]; then
        :
    else
        read -p "Do you want to clean 'bin/' before building? (y/N) " choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            rm -rf "bin"/*
            echo "Cleaned 'bin/'"
        fi
    fi
fi

# ========== Inicializa contadores ==========
compiled=0
warnings=0
errors=0
unsupported=0
notfound=0

warning_files=()
error_files=()
unsupported_files=()
notfound_files=()

declare -A used_names

# ========== Inicia log ==========
{
echo
echo "========== Build Started =========="
echo "Date: $(date)"
echo "User: $USER"
echo "System: $(uname -a)"
echo "Directory: $(pwd)"
echo "Output Directory: $BIN_DIR"
} >> "$LOG_FILE"

# ========== Detecta compiladores ==========
C_COMPILER=$(command -v gcc)
CXX_COMPILER=$(command -v g++)
if $USE_CLANG; then
    C_COMPILER=$(command -v clang)
    CXX_COMPILER=$(command -v clang++)
fi
PYTHON_INTERP=$(command -v python3)
NODE_INTERP=$(command -v node)
RUSTC=$(command -v rustc)
GO=$(command -v go)
JAVAC=$(command -v javac)
JAVA=$(command -v java)

# ========== Come√ßa compila√ß√£o ou execu√ß√£o ==========
$QUIET || echo -e "${BLUE}============== Process Started ==============${NC}"

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        $QUIET || echo -e "${RED}[NOT FOUND] File not found: $file${NC}"
        echo "[NOT FOUND] File not found: $file" >> "$LOG_FILE"
        notfound=$((notfound + 1))
        notfound_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"
    output_name="$name"

    # ========== Gerenciamento de nomes ==========
    if [[ "$RUN" == false ]]; then
        if [[ -n "${used_names[$output_name]}" ]]; then
            $QUIET || echo -e "${YELLOW}Name '$BIN_DIR/$output_name' is already in use for '${used_names[$output_name]}'${NC}"
            echo "[CONFLICT] $BIN_DIR/$output_name already used by ${used_names[$output_name]}" >> "$LOG_FILE"

            if $ASSUME_NO_ALL; then
                output_name="${name}_${ext}"
                $QUIET || echo "-> Automatically renaming '$filename' to $BIN_DIR/$output_name"
                echo "[RESOLVE] Auto rename to $output_name (previous A choice)" >> "$LOG_FILE"
            else
                while true; do
                    echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                    read -n 1 -r choice
                    echo
                    if [[ "$choice" =~ ^[Yy]$ ]]; then
                        while true; do
                            read -p "Enter new name: " newname
                            if [[ -z "$newname" ]]; then
                                echo "Name cannot be empty."
                                continue
                            fi
                            if [[ -n "${used_names[$newname]}" ]]; then
                                echo "Name '$BIN_DIR/$newname' already used."
                                continue
                            fi
                            output_name="$newname"
                            echo "[RESOLVE] Manual rename to $output_name" >> "$LOG_FILE"
                            break
                        done
                        break
                    elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                        output_name="${name}_${ext}"
                        echo "[RESOLVE] Auto rename to $output_name" >> "$LOG_FILE"
                        break
                    elif [[ "$choice" =~ ^[Aa]$ ]]; then
                        output_name="${name}_${ext}"
                        ASSUME_NO_ALL=true
                        echo "-> Automatically applying 'name_ext' for next conflicts."
                        echo "[RESOLVE] Auto rename to $output_name (A selected)" >> "$LOG_FILE"
                        break
                    else
                        echo "Please answer y, n or a."
                    fi
                done
            fi
        fi
        used_names["$output_name"]="$filename"
    fi

    # ========== RUN ==========
    if [[ "$RUN" == true ]]; then
        tmpfile="/tmp/vibe_tmp_$(date +%s%N)_$RANDOM"
        trap "rm -f $tmpfile; exit" INT TERM

        case "$ext" in
            py)
                $QUIET || echo "[PY  ] Running: $filename ($PYTHON_INTERP)"
                if grep -q '^#!.*python' "$file"; then
                    "$file"
                else
                    "$PYTHON_INTERP" "$file"
                fi
                ;;
            js)
                $QUIET || echo "[JS  ] Running: $filename ($NODE_INTERP)"
                if grep -q '^#!.*node' "$file"; then
                    "$file"
                else
                    "$NODE_INTERP" "$file"
                fi
                ;;
            c)
                $QUIET || echo "[C   ] Compiling & Running: $filename ($C_COMPILER)"
                "$C_COMPILER" "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            cpp|cc|cxx|c++)
                $QUIET || echo "[C++ ] Compiling & Running: $filename ($CXX_COMPILER)"
                "$CXX_COMPILER" "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            rs)
                $QUIET || echo "[RS  ] Compiling & Running: $filename ($RUSTC)"
                "$RUSTC" "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            go)
                $QUIET || echo "[GO  ] Compiling & Running: $filename ($GO)"
                "$GO" build -o "$tmpfile" "$file" && "$tmpfile"
                ;;
            java)
                class_name=$(basename "$file" .java)
                $QUIET || echo "[JAVA] Compiling & Running: $filename ($JAVAC)"
                "$JAVAC" "$file" -d /tmp && "$JAVA" -cp /tmp "$class_name"
                rm -f "/tmp/$class_name.class"
                ;;
            *)
                $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension for run: $filename${NC}"
                ;;
        esac

        rm -f "$tmpfile"
        continue
    fi

    # ========== BUILD ==========
    case "$ext" in
        c)
            $QUIET || echo "[C   ] Compiling: $filename -> $BIN_DIR/$output_name ($C_COMPILER)"
            output=$("$C_COMPILER" "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx|c++)
            $QUIET || echo "[C++ ] Compiling: $filename -> $BIN_DIR/$output_name ($CXX_COMPILER)"
            output=$("$CXX_COMPILER" "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        py)
            shebang=$(head -n 1 "$file")
            if [[ "$shebang" =~ ^#! ]]; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang_info="(has shebang: $shebang)"
            else
                echo '#!/usr/bin/env python3' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang_info="(added shebang: #!/usr/bin/env python3)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            $QUIET || echo "[PY  ] $filename -> $BIN_DIR/$output_name $shebang_info ($PYTHON_INTERP)"
            echo "[PY] $filename -> $BIN_DIR/$output_name $shebang_info ($PYTHON_INTERP)" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            shebang=$(head -n 1 "$file")
            if [[ "$shebang" =~ ^#! ]]; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang_info="(has shebang: $shebang)"
            else
                echo '#!/usr/bin/env node' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang_info="(added shebang: #!/usr/bin/env node)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            $QUIET || echo "[JS  ] $filename -> $BIN_DIR/$output_name $shebang_info ($NODE_INTERP)"
            echo "[JS] $filename -> $BIN_DIR/$output_name $shebang_info ($NODE_INTERP)" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        rs)
            $QUIET || echo "[RS  ] Compiling: $filename -> $BIN_DIR/$output_name ($RUSTC)"
            output=$("$RUSTC" "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        go)
            $QUIET || echo "[GO  ] Compiling: $filename -> $BIN_DIR/$output_name ($GO)"
            output=$("$GO" build -o "$BIN_DIR/$output_name" "$file" 2>&1)
            status=$?
            ;;
        java)
            $QUIET || echo "[JAVA] Compiling: $filename -> $BIN_DIR/ ($JAVAC)"
            output=$("$JAVAC" "$file" -d "$BIN_DIR" 2>&1)
            status=$?
            output_name="$name.class"
            ;;
        *)
            $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension: $filename${NC}"
            echo "[SKIP] Unsupported: $filename" >> "$LOG_FILE"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    # ========== Avalia√ß√£o ==========
    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            $QUIET || echo -e "${YELLOW}[WARN] $BIN_DIR/$output_name compiled with warnings${NC}"
            echo "[WARN] $BIN_DIR/$output_name" >> "$LOG_FILE"
            $INFO && echo "$output"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
        else
            $QUIET || echo -e "${GREEN}[ OK ] $BIN_DIR/$output_name${NC}"
            echo "[OK] $BIN_DIR/$output_name" >> "$LOG_FILE"
        fi
        compiled=$((compiled + 1))
    else
        $QUIET || echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
        echo "[FAIL] $filename" >> "$LOG_FILE"
        $INFO && echo "$output"
        errors=$((errors + 1))
        error_files+=("$filename")
    fi

done

# ========== Relat√≥rio ==========
if [[ "$RUN" == false ]]; then
    echo
    echo -e "${BLUE}================= Build Report ===================${NC}"
    echo "Compiled successfully : $compiled"
    echo "Warnings              : $warnings"
    echo -e "Errors                : ${RED}$errors${NC}"
    echo "Unsupported files     : $unsupported"
    echo "Not found files       : $notfound"

    if [[ $warnings -gt 0 ]]; then
        echo "-> Warnings in:"
        for w in "${warning_files[@]}"; do
            echo "   - $w"
        done
    fi
    if [[ $errors -gt 0 ]]; then
        echo "-> Errors in:"
        for e in "${error_files[@]}"; do
            echo "   - $e"
        done
    fi
    if [[ $unsupported -gt 0 ]]; then
        echo "-> Unsupported files:"
        for u in "${unsupported_files[@]}"; do
            echo "   - $u"
        done
    fi
    if [[ $notfound -gt 0 ]]; then
        echo "-> Not found files:"
        for n in "${notfound_files[@]}"; do
            echo "   - $n"
        done
    fi
    echo -e "${BLUE}==================================================${NC}"
    echo "========== Build Finished ==========" >> "$LOG_FILE"
fi
        		</code></pre>
			</div>
				<div class="sub-info">
					<p>
A partir daqui, se torna invi√°vel o uso do ChatGPT4o, ele n√£o consegue mais ler completamente o c√≥digo, creio que devido seu tamanho, nem reescrev√™-lo completamente, o uso da flag '-d' funciona, entretanto usando-a sem argumento (que deveria gerar os bin√°rios no diret√≥rio atual) n√£o funciona, ele acha que code.c √© um diret√≥rio em <pre> vibe -d code.c </pre> ou ent√£o a flag '-d' √© visto como arquivo em <pre> vibe code.c -d </pre> Por mais que em: <pre> vibe -d . code.c</pre> o problema seja "resolvido", a ia n√£o conseguiu reestruturar a parte do c√≥digo para manter a l√≥gica dessa flag funcional caso o diret√≥rio n√£o seja especificado
Al√©m disso, ele tamb√©m n√£o conseguiu implementar a funcionalidade de adicionar nos logs se bin/ foi limpo, e nem deixar a logo do programa com um degrad√™, assim como no instalador. Devido √† isso, o c√≥digo n√£o vale mais a pena ser continuado pela IA.<br><br>
Obs: enviando como arquivo ele aparenta conseguir ler tudo. S√≥ que seus resultados n√£o condizem com essa afirma√ß√£o, gerando c√≥digos com at√© metado do tamanho original.
					</p>
				</div>

<img src="https://i.ibb.co/tpNwZjpJ/nv.png" alt="ChatGPT's code" class="grande">
		</section>
		<br><br>
		<section id="conclusao">
			<h2>Conclus√£o</h2>
			<p>O c√≥digo atingiu seu objetivo. √â not√°vel a praticidade para cria√ß√£o de scripts mais simples usando o vibe coding. Acredito ser muito √∫til para problemas simples, grandes e demorados, mas pode ser um tiro no p√© para quest√µes mais complexas como algoritmos matem√°ticos e sistemas cr√≠ticos.
			O uso da IA, no meu caso, foi de grande ajuda pois escreveu muitas linhas em menos de um dia. Entretanto, acredito que para quem n√£o tem muita no√ß√£o do que est√° fazendo, nem das ferramentas que usa, o caso √© diferente, como aconteceu no in√≠cio quando a ideia original era usar makefile.

            Sua aplica√ß√£o √© bem √∫til, no caso usei para compilar de uma vez diversos c√≥digos de programa√ß√£o competitiva.
            
            A minha opini√£o em rela√ß√£o ao projeto √© positiva, mas vejo uma complexidade de levar isso al√©m daqui.
            O uso de shell script foi interessante por causa da interabilidade com o terminal linux.

            Apesar disso, n√£o acredito que essa forma nem de longe chegue a ser a melhor forma s√©ria, profissional e vi√°vel de se desenvolver um software.

            No meio do caminho, parecia que seria bem s√≥lido, de certa forma ainda est√°, mas com o passar do desenvolvimento provavelmente ficar√° inconsistente.
			</p>
            <br>
            <h3>
                Tempo total -><br>
                planejamente: 10 minutos.<br>
                desenvolvimento: cerca de 4/5 horas.<br>
                corre√ß√µes: 1/2 horas.<br>
                testes: menos de 1 hora, os testes n√£o foram t√£o demorados.<br>
                cria√ß√£o do projeto no github + subir p√°gina: 30 minutos.<br>
                cria√ß√£o do instalador: +/- 20 minutos.<br>
                cria√ß√£o do site: mais ou menos 5 horas. Apenas pequena parte foi usado IA.<br>
                <br>
                obs: o tempo n√£o est√° 100% preciso devido √†s pausas feitas durante o desenvolvimento do projeto.
            </h3>

            <br><br>
            <h4>Pontos Positivos:</h4>
            <p class="positivos"><strong>
                - A IA conseguiu desenvolver o projeto.<br>
                - O programa ficou funcional.<br>
                - O c√≥digo ficou at√© que leg√≠vel e estruturado.<br>
                - Superou minhas expectativas.<br>
                - O c√≥digo final n√£o mostrou lentid√£o.<br>
                - A efici√™ncia da IA se mostrou bastante superior do que no passado.<br>
                - E ela se mostrou bastante pr√°tica e √∫til em casos de muito c√≥digo repetido.
            </strong></p><br>
            <h4>Pontos Negativos:</h4>
            <p class="negativos"><strong>
                - √â extremamente d√≠ficil aprender com este processo.<br>
                - O a aba do ChatGPT ficava muito lento a ponto de crashar o computador quando gerava o c√≥digo diversas vezes (creio que pelo consumo de ram do Browser).<br>
                - √â necess√°rio ser espec√≠fico, as vezes ele n√£o faz tudo o que se espera.<br>
                - √â necess√°rio ser muito espec√≠fico, as vezes ele faz o que n√£o se espera.<br>
                - N√£o √© d√° a mesma sensa√ß√£o de programar.<br>
                - Imposs√≠vel, ou s√≥ complicado, de afirmar que fui eu quem fiz isso.<br>
                - Se eu n√£o fizesse por essa pesquisa, a fim de que apenas rodasse o que eu precisava, no caso de ser simples no sentido de escrever pouca coisa, sem adicionar funcionalidades, talvez levasse menos tempo.
                - Se fosse para um aplicativo real, isso iria ficando cada vez maior e mais complexo com o tempo, levando muito mais tempo.
            </strong></p><br>
            <h4>Detalhes:</h4>
            <p class="detalhes"><strong>
                - A op√ß√£o "-d" n√£o limpa o diret√≥rio, para evitar exclus√£o de arquivos importantes, mas poderia ser implementado, e por sorte, n√£o foi necess√°rio expecificar isso.<br>
                - Outro detalhe √© que a op√ß√£o '-d' n√£o mostra explicitamente erro ao passar um arquivo em vez de um diret√≥rio. Entretanto, poderia ser corrigido usando a IA, mas para n√£o prolongar muito, ficar√° assim mesmo, at√© por que √© intuitivo, por mais que seja uma falha, esse script n√£o tem o objetivo que ser super completo e desenvolvido como uma ferramenta real.<br>
                - O script estar√° dispon√≠vel no fim da p√°gina. Fa√ßa o download ou use o instalador do projeto.<br>
                - O tempo total de constru√ß√£o do aplicativo de umas 5/8 horas, contando com contratempos.<br>
                - Todas as expectativas b√°sicas foram realizadas, por√©m h√° coisas que poderiam ainda ser implementadas.<br>
                - No final acabou tendo mais fun√ß√µes que queriamos inicialmente (em minha opini√£o √© um fator positivo).<br>
                - Aproveitando o embalo da situa√ß√£o, esse site foi utilizado um pouco de vibe coding para seu desenvolvimento.<br>
                - Diversas vezes em que pedi mais de uma coisa consecutiva, eu mostrei somente um prompt reunindo os 3 pedidos, e aqui somente mostrei o output final.<br>
                - Momentos em que a IA acabou criando coisas que nao condizia ao escopo, e depois corrigimos, n√£o ser√£o mostrados para n√£o ficar um conte√∫do massivo.
                - O total de vers√µes do c√≥digo at√© agora foram 13 vers√µes, que s√£o separadas por alguma(s) mudan√ßa(s) significativa(s).
            </strong></p><br>
            <h4>Sobre o desenvolvimento:</h4>
            <p class="AboutDev"><strong>
                - A id√©ia do projeto surgiu quando precisei compilar cada quest√£o de https://github.com/RLois4/questoes-Obi.<br>
                - O que mais demorou provavelmente foi o tempo de espera para a IA gerar o c√≥digo.<br>
                - Em momento nenhum houve quebra ou erro de funcionalidades antigas com as implementadas naquela hora.
            </strong></p><br>
            <h4>A IA amea√ßa o mercado de trabalho da programa√ß√£o?</h4>
            <p class="AboutDev"><strong>
                - Para quem trabalha com solu√ß√µes simples, como criar um blog est√°tico ou scripts de automa√ß√£o menores, talvez sim.<br>
                - Diria que a IA n√£o teria capacidade nesses pr√≥ximos anos para substituir igualmente um humano no seu trabalho em determinados setores da programa√ß√£o.<br>
                - Designs mais complexos, Backends com alta necessidade de desempenho, programa√ß√£o em embarcados de mais baixo n√≠vel, algoritmos matem√°ticos com alto grau de dificuldade que precisam de complexidades Big-O m√≠nimos e sistemas que gerenciam dados sens√≠veis s√£o exemplos de coisas que nem podemos pensar em atribuir o trabalho √†s IA's.
            </strong></p>
		</section>
    </section>
    <section class="about">
    <h2>Sobre o Projeto</h2>
    <div class="ascii-art">
<pre>
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       O       Idealizado Por:    Programado Por ‚îÇ
‚îÇ      _|_   Renato L√≥is M. Silva     ChatGPT4o   ‚îÇ
‚îÇ     /   \  Luiz Eduardo G. Cidade               ‚îÇ
‚îÇ     () ()  Davi Eduardo S. de Lima              ‚îÇ
‚îÇ    ,|_ _|,                                      ‚îÇ
‚îÇ  _/_______\_ ....         VibeBuild             ‚îÇ
‚îÇ  \  < / >  / |--|)                              ‚îÇ
‚îÇ   \_______/  |__|  Um script para compilar tudo ‚îÇ 
‚îÇ                                                 ‚îÇ
‚îÇ          https://vibebuild.github.io/           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</pre>
    </div>

    <p><strong>VibeBuild</strong> √© uma ferramenta simples para automa√ß√£o de compila√ß√£o.</p>
    <p>Ela nasceu da minha necessidade de compilar pequenos trechos de c√≥digo de forma r√°pida e pr√°tica, sem precisar configurar Makefiles ou outras ferramentas complexas.</p>
    <p>Juntando isso com uma pesquisa escolar sobre <em>vibe coding</em>, nasceu o <strong>VibeBuild</strong>.</p>

    <h3>‚ú® Funcionalidades</h3>
    <ul>
        <li>üõ†Ô∏è Compila√ß√£o r√°pida para pequenos c√≥digos.</li>
        <li>üöÄ Suporte a m√∫ltiplas linguagens.</li>
        <li>üìú Gera√ß√£o de log detalhado.</li>
        <li>üî• Executar ap√≥s compilar (<code>--run</code> ou <code>-r</code>).</li>
        <li>üèóÔ∏è Alterar de GCC pra CLANG (<code>--clang</code>).</li>
        <li>üìÅ Definir o diret√≥rio de sa√≠da (<code>-d</code>).</li>
    </ul>

    <h3>üöÄ Como Usar</h3>
    <ol>
        <li>Clone o reposit√≥rio:
            <pre class="prompt">git clone https://github.com/VibeBuild/vibebuild.github.io<br>cd vibebuild.github.io</pre>
        </li>
        <li>Deixe o instalador execut√°vel:
            <pre class="prompt">chmod +x installer</pre>
        </li>
        <li>Execute para instalar:
            <pre class="prompt">./installer</pre>
        </li>
        <li>Execute o programa:
            <pre class="prompt">vibe</pre>
        </li>
    </ol>

    <h3>üîó Links</h3>
    <p>üî• Projeto no GitHub: <a href="https://github.com/VibeBuild/vibebuild.github.io" target="_blank">https://github.com/VibeBuild/vibebuild.github.io</a></p>

    <h3>üìú Licen√ßa</h3>
    <p>Este projeto est√° licenciado sob a Licen√ßa GPL. Veja o arquivo <a href="https://github.com/VibeBuild/vibebuild.github.io/blob/main/LICENSE" target="_blank">LICENSE</a> para mais detalhes.</p>

    <blockquote>‚Äú<strong>One script to build them all.</Script></strong>‚Äù<br>‚Äî <em>VibeBuild</em></blockquote>
<img src="https://i.ibb.co/k6Kv3JdM/image.png" alt="VibeBuild output" class="noborder">
</section>

        <div class="download-container">
            <a href="https://vibebuild.github.io/VibeBuild" download class="download-button">Download</a>
        </div>

		<footer>
			<p>&copy; 2025 Vibe Build. Todos os direitos reservados.</p>
		</footer>
		<script>
			function copyCode(button) {
			    const code = button.nextElementSibling.innerText;
			    navigator.clipboard.writeText(code).then(() => {
			        button.innerText = "Copiado!";
			        setTimeout(() => {
			            button.innerText = "Copiar";
			        }, 2000);
			    });
			}
		</script>
	</body>
</html>
