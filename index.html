<!DOCTYPE html>
<html lang="pt-br">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
		<title>Projeto - Análise e Resenha</title>
		<style>
			* { margin: 0; padding: 0; box-sizing: border-box; scroll-behavior: smooth; }
			body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #121212; color: white; }
			header { background-color: #1f1f1f; padding: 20px; position: fixed; width: 100%; top: 0; z-index: 1000; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
			nav { display: flex; justify-content: space-between; align-items: center; max-width: 1200px; margin: auto; }
			nav h1 { color: #00ffcc; }
			nav ul { list-style: none; display: flex; gap: 20px; }
			nav ul li a { color: white; text-decoration: none; transition: color 0.3s; }
			nav ul li a:hover { color: #00ffcc; }
			section { padding: 100px 20px 60px; max-width: 1000px; margin: auto; }
			section h2 { color: #00ffcc; margin-bottom: 20px; }
			h3 { color: #00ffcc; margin-top: 40px; margin-bottom: 10px; }
			.hero { background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.7)), url('https://i.ibb.co/LXQdK614/Chat-GPT-Image-May-25-2025-02-08-55-PM.png') center/cover; height: 60vh; display: flex; justify-content: center; align-items: center; text-align: center; }
			.hero h1 { font-size: 3rem; color: white; }
			.hero p { margin-top: 10px; color: #ccc; }
			footer { background-color: #1f1f1f; text-align: center; padding: 20px; color: #aaa; }
			pre { background-color: #1e1e1e; padding: 15px; border-radius: 10px; overflow-x: auto; color: #00ffcc; margin-bottom: 20px; }
			.sub-info { background-color: #1e1e1e; border-left: 5px solid #00ffcc; padding: 15px 20px; margin-top: 15px; border-radius: 8px; color: #ccc; }
			strong { color: #00ffcc; }
			.code-container {
			position: relative;
			}
            .positivos strong {
                color: rgb(92, 182, 255);
            }
            .negativos strong {
                color: rgb(255, 115, 115);
            }
            .detalhes strong {
                color: rgb(247, 255, 171);
            }
            pre.prompt {
                color: white !important;
            }
            .about {
    background-color: #1e1e1e;
    padding: 40px;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    max-width: 900px;
    margin: 50px auto;
    font-family: 'Courier New', monospace;
}
img:not(.noborder) {
 border: 5px solid #34ff89;
}

img {
width: 60%; height: auto;
margin:10px;
}

.grande {
	width: 80%;
}

.about h2 {
    color: #00ffcc;
    margin-bottom: 20px;
    text-align: center;
}

.about h3 {
    color: #00ffcc;
    margin-top: 30px;
}

.about p {
    margin-bottom: 15px;
    color: #ccc;
}

.about ul, .about ol {
    margin-left: 20px;
    margin-bottom: 20px;
    color: #ccc;
}

.about li {
    margin-bottom: 8px;
}

.about a {
    color: #9c67ff;
    text-decoration: none;
}

.about a:hover {
    text-decoration: underline;
}

.about pre {
    background-color: #121212;
    padding: 15px;
    border-radius: 8px;
    overflow-x: auto;
    color: #00ffcc;
    margin: 10px 0;
}

.about blockquote {
    border-left: 4px solid #00ffcc;
    padding-left: 15px;
    color: #aaa;
    margin-top: 20px;
    font-style: italic;
}

.ascii-art {
    text-align: center;
    margin-bottom: 20px;
}

.ascii-art pre {
    display: inline-block;
    text-align: left;
}

			.copy-button {
			position: absolute;
			top: 10px;
			right: 10px;
			background-color: #00ffcc;
			color: #121212;
			border: none;
			padding: 5px 10px;
			border-radius: 5px;
			cursor: pointer;
			font-size: 0.8rem;
			opacity: 0.7;
			transition: opacity 0.3s;
			}
			.copy-button:hover {
			opacity: 1;
			}
            .container_ {
                gap: 20px;
            }
            .container_ a {
                color: #9c67ff
            }
            img {
                padding-top: 20px;
            }
.download-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 50px 0;
}

.download-button {
    display: inline-block;
    background-color: #00ffcc;
    color: #121212;
    padding: 14px 28px;
    border-radius: 10px;
    text-decoration: none;
    font-weight: bold;
    font-size: 1rem;
    transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
    box-shadow: 0 5px 20px rgba(0, 255, 204, 0.3);
}

.download-button:hover {
    background-color: #00e6b8;
    transform: translateY(-3px);
    box-shadow: 0 8px 30px rgba(0, 255, 204, 0.5);
}

.download-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 10px rgba(0, 255, 204, 0.2);
}
.downloadinbar {
    color: #00e6b8;
}
.downloadinbar:hover {
     text-shadow:
        -1px -1px 0 rgb(1, 69, 78),
         1px -1px 0 rgb(14, 175, 148),
        -1px  1px 0 rgb(59, 86, 235),
         1px  1px 0 rgb(20, 126, 126);
}
		</style>
	</head>
	<body>
		<header>
			<nav>
				<h1>Vibe Build</h1>
				<ul>
					<li><a href="#objetivo">Objetivo</a></li>
					<li><a href="#ambiente">Ambiente</a></li>
                    <li><a href="#autor">Autor</a></li>
					<li><a href="#foco">Focos</a></li>
					<li><a href="#desenvolvimento">Desenvolvimento</a></li>
                    <li><a href="#conclusao">Conclusão</a></li>
                    <li><a href="https://vibebuild.github.io/VibeBuild" download class="downloadinbar">Download</a></li>
				</ul>
			</nav>
		</header>
		<div class="hero">
			<div>
				<h1>Projeto: VibeBuild</h1>
				<p>Documentação, processo e resultados</p>
			</div>
		</div>
			<section id="objetivo" class="container_">
				<h2>Objetivo</h2>
				<p>Desenvolver um script de build para compilar / gerar um executável de pequenos códigos, depois veremos a necessidade de trabalhar com mais de um arquivo por vez. Sendo interessante também a idéia de poder rodar os códigos, principalmente os que não são interpretados.<br><br><br>
                <h5>Expectativas:</h5><br>
                - Terminar em um dia [realizado, com pequenas alterações no outro dia, nada demais]<br>
                - Compilar corretamente cada arquivo de forma separada e enviar para uma pasta (./bin/) [realizado]<br>
                - Ser simples de utilizar [realizado]
                </p>
            </section>
			<section id="ambiente" class="container_">
				<h2>Ambiente</h2>
				<p>
					- OS: Arch Linux x86_64<br>
					- Browser: Chromium 136.0.7103.113<br>
					- Shell: GNU bash, version 5.2.37(1)-release<br>
                    - IA: ChatGPT4o Openai<br>
                    - Linguagem: Makefile (trocada logo no início do projeto por BashScript)<br>
                    - Terminal emulator: Kitty 0.42.0
				</p>
			</section>
            <section id="autor" class="container_">
				<h2>Autor</h2>
				<p>
					- Turma 1203<br><br>
					- Renato Lóis Marcondes da Silva, N° 22<br>
          			- Email Institucional: 244084.aluno@iserj.edu.br<br><br>
          			- Luiz Eduardo Guerra Cidade, N° 16<br>
          			- Email Institucional: 244077.aluno@iserj.edu.br<br><br>
			        - Davi Eduardo Santos de Lima, N° 7<br>
          			- Email Institucional: 244065.aluno@iserj.edu.br<br>
				</p>
			</section>
			<br><br>
			<section id="foco" class="container_">
				<h2>Focos do Projeto</h2>
				<p>- Agilizar a compilação e execução de códigos simples e pequenos em diferentes linguagens.<br>
					- Reduzir a necessidade de comandos manuais.<br>
					- Proporcionar uma experiência mais fluida para testes rápidos de scripts.
				</p>
			</section>
			<br><br>
		<section id="desenvolvimento">
			<h1>Desenvolvimento do Código</h1>
			<br>
			<h2>1. Makefile Inicial</h2>
			<p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
criar um script makefile que receba "make nomedoarquivo" e entao,
se for c++ ele compilar para c++, se for c, para c, se for python,
so rodar python e nome do arquivo</pre>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
# Uso:
# make nome_do_arquivo (sem extensão)

FILE=$(firstword $(MAKECMDGOALS))

EXTENSION = $(shell find . -maxdepth 1 -type f -name "$(FILE).*" | sed -n 's/.*\.\([^.]*\)$$/\1/p')

ifeq ($(EXTENSION),cpp)
	COMMAND = g++ -o $(FILE) $(FILE).cpp && ./$(FILE)
endif

ifeq ($(EXTENSION),c)
	COMMAND = gcc -o $(FILE) $(FILE).c && ./$(FILE)
endif

ifeq ($(EXTENSION),py)
	COMMAND = python3 $(FILE).py
endif

ifeq ($(EXTENSION),)
	COMMAND = echo "Arquivo $(FILE) não encontrado."
endif

all:
	@$(COMMAND)</code>
        </pre>
			</div>
			<div class="resultado">
				<h3>Resultado</h3>
				<p>O Makefile apresentou limitações na execução direta. Conseguiu compilar códigos C e C++, mas não rodou corretamente código Python.</p>
				<div class="sub-info">
					<p>Após isso, surgiu a ideia de adicionar a função de compilar mais de um código gerando diversos binários, com somente um comando, deixando de lado momentâneamente o problema de não rodar Python. O código Makefile notou-se complexo, pois como dito, não tenho experiência nem conhecimento significativo dessa ferramenta, então decidimos trocar para bash script.
					</p>
				</div>
			</div>
            <img src="https://i.ibb.co/7N1hr8s0/makefileerror.png" alt="makefile code output">
			<br><br>
			<br><br>
			<br><br>
			<br><br>
			<h2>2. Migração para Shell Script</h2>
			<p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
um codigo shell que receba o nome do arquivo com ou sem extensao,
se for c, faz gcc, c++ g++, somente isso, e crie ./bin/ se nao existir
e mande para la o binário
        </pre>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Verifica se foi passado argumento
if [ -z "$1" ]; then
    echo "❌ Uso: ./build.sh nome_do_arquivo[.c|.cpp]"
    exit 1
fi

# Nome base e extensão
input="$1"
name="${input%.*}"  # Remove extensão, se tiver
ext="${input##*.}"  # Pega a extensão

# Se não tiver extensão, tenta descobrir
if [ "$ext" = "$input" ]; then
    if [ -f "$input.c" ]; then
        ext="c"
        input="$input.c"
    elif [ -f "$input.cpp" ]; then
        ext="cpp"
        input="$input.cpp"
    else
        echo "❌ Arquivo '$input.[c|cpp]' não encontrado."
        exit 1
    fi
fi

# Cria pasta bin se não existir
mkdir -p bin

# Compila de acordo com a extensão
if [ "$ext" = "c" ]; then
    echo "🔧 Compilando C: $input -> bin/$name"
    gcc "$input" -o "bin/$name"
elif [ "$ext" = "cpp" ]; then
    echo "🔧 Compilando C++: $input -> bin/$name"
    g++ "$input" -o "bin/$name"
else
    echo "❌ Extensão .$ext não suportada."
    exit 1
fi

# Mensagem final
if [ $? -eq 0 ]; then
    echo "✅ Binário criado em: bin/$name"
else
    echo "❌ Erro na compilação."
    exit 1
fi
			</code></pre>
			</div>
			<br><br>
			<p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
agora ele vai receber varios arquivos
				</pre>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Verifica se recebeu pelo menos um arquivo
if [ $# -eq 0 ]; then
    echo "❌ Uso: ./build.sh arquivo1 [arquivo2 ...]"
    exit 1
fi

# Cria bin se não existir
mkdir -p bin

# Loop sobre todos os argumentos
for input in "$@"; do
# Remove extensão (se tiver)
name="${input%.*}"
ext="${input##*.}"

    # Se não tiver extensão, tenta achar
    if [ "$ext" = "$input" ]; then
    if [ -f "$input.c" ]; then
            ext="c"
            input="$input.c"
        elif [ -f "$input.cpp" ]; then
        ext="cpp"
            input="$input.cpp"
            else
            echo "❌ Arquivo '$input.[c|cpp]' não encontrado."
            continue
        fi
    fi
    
    # Verifica se o arquivo realmente existe
    if [ ! -f "$input" ]; then
    echo "❌ Arquivo '$input' não encontrado."
        continue
    fi
    
    # Compila
    if [ "$ext" = "c" ]; then
        echo "🔧 Compilando C: $input -> bin/$name"
        gcc "$input" -o "bin/$name"
    elif [ "$ext" = "cpp" ]; then
        echo "🔧 Compilando C++: $input -> bin/$name"
        g++ "$input" -o "bin/$name"
    else
        echo "❌ Extensão '.$ext' não suportada para '$input'."
        continue
    fi

    if [ $? -eq 0 ]; then
        echo "✅ Sucesso: bin/$name"
    else
    echo "❌ Erro ao compilar: $input"
    fi
done
			</code></pre>
            <img src="https://i.ibb.co/5XPy5kh6/op.png" alt="VibeBuild output">
			</div>
			<div class="resultado">
				<h3>Resultado</h3>
				<p>O código já se encontra funcional para C e C++, entretanto o uso de emoji deve ser evitado em aplicações CLI, então esse detalhe deverá ser removido. Além disso, ao compilar diversos arquivos, o output de warnings e erros do compilador causa desconforto visual, então será necessário um output mais compacto (de preferencia em inglês), além de que o programa deverá rodar com outras linguagens.</p>
				<div class="sub-info">
                    <p>Uma coisa que alterarei é que em vez de rodar python diretamente, será copiado o código com um shebang (se já não existir) para o diretório bin com permissão de execução. Os warnings e erros de compilação serão suprimidos, e aparecerão apenas se pedido explicitamente.</p>
				</div>
			</div>
			<br><br>
			<br><br>
			<br><br>
			<br><br>
			<h2>2. Aprimoramento do código base</h2>
			<p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
Trocar os emoji, melhor sem ser emoji, e torne mais agradavel 
a vista, no final, faca um relatorio, tem que ser tudo em ingles, 
se tudo ocorreu bem, se houve erro, se sim, mostre quantos deram 
warning, quantos deram erro, e aceite uma flag --info para mostrar 
os warning e erros, se nao, so compile, por padrão nao mostre os 
erro do gcc e do g++, etc.</pre>
<p><strong>Versão desenvolvida:</strong></p>
<div class="code-container">
    <button class="copy-button" onclick="copyCode(this)">Copiar</button>
    <pre><code class="language-bash">
#!/bin/bash

# =============================
# CONFIGURATION
# =============================
BIN_DIR="bin"
mkdir -p "$BIN_DIR"

SHOW_INFO=false
FILES=()

# =============================
# ARGUMENT PARSING
# =============================
for arg in "$@"; do
if [ "$arg" == "--info" ]; then
SHOW_INFO=true
else
        FILES+=("$arg")
    fi
    done

if [ ${#FILES[@]} -eq 0 ]; then
    echo "Usage: ./compiler.sh [--info] file1 [file2 ...]"
    exit 1
fi

# =============================
# INITIALIZATION
# =============================
success_count=0
warning_count=0
error_count=0

declare -A warnings
declare -A errors

# =============================
# BUILD PROCESS
# =============================
for input in "${FILES[@]}"; do

if [ -d "$input" ]; then
continue
fi

    name="${input%.*}"
    ext="${input##*.}"
    
    if [ "$ext" == "$input" ]; then
    if [ -f "$input.c" ]; then
    ext="c"
    input="$input.c"
    elif [ -f "$input.cpp" ]; then
    ext="cpp"
    input="$input.cpp"
    else
            echo "[ERROR] Source file '$input.[c|cpp]' not found."
            ((error_count++))
            errors["$input"]="File not found"
            continue
        fi
        fi
    
        if [ ! -f "$input" ]; then
        echo "[ERROR] Source file '$input' not found."
        ((error_count++))
        errors["$input"]="File not found"
        continue
    fi
    
    echo "Compiling $input -> $BIN_DIR/$name"
    
    compile_cmd=""
    if [ "$ext" == "c" ]; then
    compile_cmd="gcc \"$input\" -o \"$BIN_DIR/$name\""
    elif [ "$ext" == "cpp" ]; then
    compile_cmd="g++ \"$input\" -o \"$BIN_DIR/$name\""
    else
    echo "[ERROR] Unsupported extension '.$ext' for '$input'."
    ((error_count++))
    errors["$input"]="Unsupported extension"
    continue
    fi
    
    if $SHOW_INFO; then
    output=$(eval $compile_cmd 2>&1)
    else
    output=$(eval $compile_cmd 2>&1 >/dev/null)
    fi
    
    status=$?
    
    if [ $status -eq 0 ]; then
    if [[ "$output" == *"warning"* ]]; then
    ((warning_count++))
    warnings["$input"]="$output"
    echo "[WARNING] Compiled with warnings."
    else
    ((success_count++))
    echo "[OK] Compiled successfully."
    fi
    else
    ((error_count++))
    errors["$input"]="$output"
    echo "[ERROR] Failed to compile."
    fi
    done
    
    # =============================
    # REPORT
    # =============================
    echo ""
    echo "================ Build Report ================"
    echo "Total files: $((success_count + warning_count + error_count))"
echo "Successful builds: $success_count"
echo "Builds with warnings: $warning_count"
echo "Failed builds: $error_count"
echo "=============================================="

if $SHOW_INFO; then
if [ ${#warnings[@]} -gt 0 ]; then
        echo ""
        echo "Warnings:"
        for file in "${!warnings[@]}"; do
        echo "---- $file ----"
        echo "${warnings[$file]}"
        echo ""
        done
        fi

    if [ ${#errors[@]} -gt 0 ]; then
    echo ""
        echo "Errors:"
        for file in "${!errors[@]}"; do
            echo "---- $file ----"
            echo "${errors[$file]}"
            echo ""
            done
            fi
            fi
            
            exit 0
        </code></pre>
        <img src="https://i.ibb.co/sJs6RqBq/s1.png" alt="VibeBuild output">
			</div>
            <br><br>
			<p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
agora adicione a funcionalidade de que quando for um código python, 
verifique se há um shebang como #!usr/bin/env python3, se nao, 
adicione, e copie para bin com permissao de execucao, use chmod 
para isso, para o python, pois gcc e g++ ja o tornam executaveis.
Os arquivos agora só serão com extensão.            
            </pre>
            </pre>
                <div class="sub-info">
                    <p>Aqui percebo que o uso do nome do arquivo sem extensão pode gerar ambiguidade, então essa ideia será deixada de lado.
                </p>
            </div>
            <br>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
                <button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Cria pasta bin se não existir
mkdir -p bin

INFO=false
if [[ $1 == "--info" ]]; then
    INFO=true
    shift
fi

compiled=0
warnings=0
errors=0
unsupported=0

warning_files=()
error_files=()
unsupported_files=()

echo "============== Compilation Started =============="

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        echo "[SKIP] File not found: $file"
        unsupported=$((unsupported + 1))
        unsupported_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"

    case "$ext" in
        c)
            echo "[C   ] Compiling: $filename -> bin/$name"
            output=$(gcc "$file" -o "bin/$name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx)
            echo "[C++ ] Compiling: $filename -> bin/$name"
            output=$(g++ "$file" -o "bin/$name" 2>&1)
            status=$?
            ;;
        py)
            echo "[PY  ] Processing: $filename -> bin/$name"
            # Verifica se possui shebang
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "bin/$name"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env python3'; cat "$file"; } > "bin/$name"
            fi
            chmod +x "bin/$name"
            echo "[ OK ] bin/$name"
            compiled=$((compiled + 1))
            continue
            ;;
        *)
            echo "[SKIP] Unsupported extension: $filename"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            echo "[WARN] bin/$name compiled with warnings"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
            $INFO && echo "$output"
        else
            echo "[ OK ] bin/$name"
        fi
        compiled=$((compiled + 1))
    else
        echo "[FAIL] Compilation failed: $filename"
        errors=$((errors + 1))
        error_files+=("$filename")
        $INFO && echo "$output"
    fi

done

echo
echo "================= Build Report ==================="
echo "Compiled successfully : $compiled"
echo "Warnings             : $warnings"
echo "Errors               : $errors"
echo "Unsupported files    : $unsupported"

if [[ $warnings -gt 0 ]]; then
    echo "-> Warnings in:"
    for w in "${warning_files[@]}"; do
        echo "   - $w"
    done
fi

if [[ $errors -gt 0 ]]; then
    echo "-> Errors in:"
    for e in "${error_files[@]}"; do
        echo "   - $e"
    done
fi

if [[ $unsupported -gt 0 ]]; then
    echo "-> Unsupported files:"
    for u in "${unsupported_files[@]}"; do
        echo "   - $u"
    done
fi

echo "=================================================="
        		</code></pre>
			</div>
			<br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
faça uma verificação se há arquivos com o mesmo nome, 
por exemplo a.c e a.py, nesse caso, capture da entrada 
padrão se quer renomear manualmente ou não, por padrão 
(se apenas houver enter) entende-se como um não  (com y/N) 
e nesse caso renomeie cada arquivo executavel gerado para 
filename_extension, no caso, serão gerados respectivamente 
a_c e a_py. Essa funcionalidade deve ser implementada no 
código. O arquivo original nao deve ter seu nome trocado. 
Se a opcao selecionado for Y, a pessoa deverá digitar o
nome do binário a ser gerado, antes de gerar, esse nome 
deverá passar novamente por verificação, em loop até não 
haver conflito. Em caso de y, o binario deve ser o 
bin/inputinserido, em caso de n, deverá ser bin/b_py. 
Lembre-se de fazer em inglês.
            </pre>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Create bin directory if it doesn't exist
mkdir -p bin

INFO=false
if [[ $1 == "--info" ]]; then
    INFO=true
    shift
fi

compiled=0
warnings=0
errors=0
unsupported=0

warning_files=()
error_files=()
unsupported_files=()

declare -A bin_names
declare -A name_count

# ===========================
# 🔍 Count base filenames
# ===========================
for file in "$@"; do
    filename=$(basename -- "$file")
    name="${filename%.*}"
    name_count["$name"]=$((name_count["$name"] + 1))
done

# ===========================
# 🎯 Define output names
# ===========================
for file in "$@"; do
    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"

    case "$ext" in
        c|cpp|cc|cxx|py)
            if [[ ${name_count["$name"]} -gt 1 ]]; then
                echo "⚠️  Conflict: '$filename' would generate binary with duplicated name '$name'"
                read -p "Do you want to choose a custom binary name? (y/N): " choice
                choice=${choice,,}

                if [[ "$choice" == "y" ]]; then
                    while true; do
                        read -p "Enter the binary name for '$filename': " custom_name
                        if [[ -z "$custom_name" ]]; then
                            echo "❌ Invalid name. Try again."
                        elif [[ -n "${bin_names[$custom_name]}" || -e "bin/$custom_name" ]]; then
                            echo "❌ Name '$custom_name' is already in use. Try another one."
                        else
                            bin_names["$filename"]="$custom_name"
                            break
                        fi
                    done
                else
                    bin_names["$filename"]="${name}_${ext}"
                fi
            else
                bin_names["$filename"]="$name"
            fi
            ;;
        *)
            continue
            ;;
    esac
done

# ===========================
# 🔧 Compilation and Processing
# ===========================
echo "============== Compilation Started =============="

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        echo "[SKIP] File not found: $file"
        unsupported=$((unsupported + 1))
        unsupported_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    ext="${filename##*.}"
    output_name="${bin_names[$filename]:-${filename%.*}}"

    case "$ext" in
        c)
            echo "[C   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx)
            echo "[C++ ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        py)
            echo "[PY  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "bin/$output_name"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env python3'; cat "$file"; } > "bin/$output_name"
            fi
            chmod +x "bin/$output_name"
            echo "[ OK ] bin/$output_name"
            compiled=$((compiled + 1))
            continue
            ;;
        *)
            echo "[SKIP] Unsupported extension: $filename"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            echo "[WARN] bin/$output_name compiled with warnings"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
            $INFO && echo "$output"
        else
            echo "[ OK ] bin/$output_name"
        fi
        compiled=$((compiled + 1))
    else
        echo "[FAIL] Compilation failed: $filename"
        errors=$((errors + 1))
        error_files+=("$filename")
        $INFO && echo "$output"
    fi
done

# ===========================
# 📊 Final Build Report
# ===========================
echo
echo "================= Build Report ==================="
echo "Compiled successfully : $compiled"
echo "Warnings              : $warnings"
echo "Errors                : $errors"
echo "Unsupported files     : $unsupported"

[[ $warnings -gt 0 ]] && echo "-> Warnings in:" && for w in "${warning_files[@]}"; do echo "   - $w"; done
[[ $errors -gt 0 ]] && echo "-> Errors in:" && for e in "${error_files[@]}"; do echo "   - $e"; done
[[ $unsupported -gt 0 ]] && echo "-> Unsupported files:" && for u in "${unsupported_files[@]}"; do echo "   - $u"; done

echo "=================================================="
        		</code></pre>
			</div>

            <div class="sub-info">
                <p> A IA voltou a usar emoji pois houve um equívoco, a aba de navegação foi trocada e na verdade o desenvolvimento do código foi feito por outra que não recebeu os prompts anteriores. E por isso, enviei o código novamente. Nota-se a grande capacidade de se adaptar ao contexto por parte da inteligência artificial.
                </p>
            </div>
            <br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
                se eu tenho b.py e b.c, e eu altero b.py, nao tem conflito 
                mais com b.c, entao nao ha porque mostrar de novo em b.c, 
                e se eu troco b.py para appexec, entao nao posso dar o nome
                appexec para o binario de b.c. Entretanto, se ainda não há 
                por exemplo arquivo chamado b, então posso criar o b para py 
                sem ser chamado atenção, o pedido para renomeação deve ser 
                instanciado no último caso possivel no caso, se tenho b.py, 
                e b.c, e o primeiro é b.py, ele deve "compilar" b.py como 
                bin/b e perguntar oq fazer com b.c. e quando perguntar para 
                renomear, tem q estar explicito qual arquivo esta sendo 
                compilado. E se possível em bash script, o y/N ser capturado 
                antes do Enter, deve haver uma opção 'a', ficando
                a/y/N, sendo 'a' um 'n' para todas os próximos casos de conflito. 
                retire os emojis também.
            </pre>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Cria pasta bin se não existir
mkdir -p bin

# Verifica se quer modo info
INFO=false
while [[ "$1" == "--info" || "$1" == "-i" ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
    esac
    shift
done

compiled=0
warnings=0
errors=0
unsupported=0

warning_files=()
error_files=()
unsupported_files=()

# Controle de nomes ocupados
declare -A used_names

# Flag para "não perguntar mais, usar name_ext automaticamente"
ASSUME_NO_ALL=false

echo "============== Compilation Started =============="

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        echo "[SKIP] File not found: $file"
        unsupported=$((unsupported + 1))
        unsupported_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"

    output_name="$name"

    # Verificar se o nome já está em uso
    if [[ -n "${used_names[$output_name]}" ]]; then
        echo "Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'."

        if $ASSUME_NO_ALL; then
            output_name="${name}_${ext}"
            echo "-> Automatically renaming '$filename' to bin/$output_name due to previous 'a' choice."
        else
            while true; do
                echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                read -n 1 -r choice
                echo
                if [[ "$choice" =~ ^[Yy]$ ]]; then
                    while true; do
                        read -p "Enter new name for '$filename': " newname
                        if [[ -z "$newname" ]]; then
                            echo "Name cannot be empty."
                            continue
                        fi
                        if [[ -n "${used_names[$newname]}" ]]; then
                            echo "Name 'bin/$newname' is already in use for '${used_names[$newname]}'."
                            continue
                        fi
                        output_name="$newname"
                        break
                    done
                    break
                elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                    output_name="${name}_${ext}"
                    break
                elif [[ "$choice" =~ ^[Aa]$ ]]; then
                    output_name="${name}_${ext}"
                    ASSUME_NO_ALL=true
                    echo "-> Automatically applying 'name_ext' for all next conflicts."
                    break
                else
                    echo "Please answer y, n or a."
                fi
            done
        fi
    fi

    # Registrar nome como usado
    used_names["$output_name"]="$filename"

    # Compilação/Processamento
    case "$ext" in
        c)
            echo "[C   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx)
            echo "[C++ ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        py)
            echo "[PY  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "bin/$output_name"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env python3'; cat "$file"; } > "bin/$output_name"
            fi
            chmod +x "bin/$output_name"
            echo "[ OK ] bin/$output_name"
            compiled=$((compiled + 1))
            continue
            ;;
        *)
            echo "[SKIP] Unsupported extension: $filename"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            echo "[WARN] bin/$output_name compiled with warnings"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
            $INFO && echo "$output"
        else
            echo "[ OK ] bin/$output_name"
        fi
        compiled=$((compiled + 1))
    else
        echo "[FAIL] Compilation failed: $filename"
        errors=$((errors + 1))
        error_files+=("$filename")
        $INFO && echo "$output"
    fi

done

echo
echo "================= Build Report ==================="
echo "Compiled successfully : $compiled"
echo "Warnings             : $warnings"
echo "Errors               : $errors"
echo "Unsupported files    : $unsupported"

if [[ $warnings -gt 0 ]]; then
    echo "-> Warnings in:"
    for w in "${warning_files[@]}"; do
        echo "   - $w"
    done
fi

if [[ $errors -gt 0 ]]; then
    echo "-> Errors in:"
    for e in "${error_files[@]}"; do
        echo "   - $e"
    done
fi

if [[ $unsupported -gt 0 ]]; then
    echo "-> Unsupported files:"
    for u in "${unsupported_files[@]}"; do
        echo "   - $u"
    done
fi

echo "=================================================="
        	    </code></pre>
			</div>
			<br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
agora adicione as opcoes também para java, rust, js e go.
no estilo:
rustc hello.rs -o hello
go build -o hello hello.go
o js, tu coloca shebang para node, mas o mesmo esquema de python, sempre verifique se ja nao tem um shebang.
javac HelloWorld.java -d bin, gerando .class mesmo
            </pre>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# Cria pasta bin se não existir
mkdir -p bin

# Verifica se quer modo info
INFO=false
while [[ "$1" == "--info" || "$1" == "-i" ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
    esac
    shift
done

compiled=0
warnings=0
errors=0
unsupported=0

warning_files=()
error_files=()
unsupported_files=()

# Controle de nomes ocupados
declare -A used_names

# Flag para "não perguntar mais, usar name_ext automaticamente"
ASSUME_NO_ALL=false

echo "============== Compilation Started =============="

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        echo "[SKIP] File not found: $file"
        unsupported=$((unsupported + 1))
        unsupported_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"

    output_name="$name"

    # Verificar se o nome já está em uso
    if [[ -n "${used_names[$output_name]}" ]]; then
        echo "Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'."

        if $ASSUME_NO_ALL; then
            output_name="${name}_${ext}"
            echo "-> Automatically renaming '$filename' to bin/$output_name due to previous 'a' choice."
        else
            while true; do
                echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                read -n 1 -r choice
                echo
                if [[ "$choice" =~ ^[Yy]$ ]]; then
                    while true; do
                        read -p "Enter new name for '$filename': " newname
                        if [[ -z "$newname" ]]; then
                            echo "Name cannot be empty."
                            continue
                        fi
                        if [[ -n "${used_names[$newname]}" ]]; then
                            echo "Name 'bin/$newname' is already in use for '${used_names[$newname]}'."
                            continue
                        fi
                        output_name="$newname"
                        break
                    done
                    break
                elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                    output_name="${name}_${ext}"
                    break
                elif [[ "$choice" =~ ^[Aa]$ ]]; then
                    output_name="${name}_${ext}"
                    ASSUME_NO_ALL=true
                    echo "-> Automatically applying 'name_ext' for all next conflicts."
                    break
                else
                    echo "Please answer y, n or a."
                fi
            done
        fi
    fi

    # Registrar nome como usado
    used_names["$output_name"]="$filename"

    # Compilação/Processamento
    case "$ext" in
        c)
            echo "[C   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx)
            echo "[C++ ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        py)
            echo "[PY  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "bin/$output_name"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env python3'; cat "$file"; } > "bin/$output_name"
            fi
            chmod +x "bin/$output_name"
            echo "[ OK ] bin/$output_name"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            echo "[JS  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*node' "$file"; then
                cp "$file" "bin/$output_name"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env node'; cat "$file"; } > "bin/$output_name"
            fi
            chmod +x "bin/$output_name"
            echo "[ OK ] bin/$output_name"
            compiled=$((compiled + 1))
            continue
            ;;
        rs)
            echo "[RUST] Compiling: $filename -> bin/$output_name"
            output=$(rustc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            ;;
        go)
            echo "[GO  ] Compiling: $filename -> bin/$output_name"
            output=$(go build -o "bin/$output_name" "$file" 2>&1)
            status=$?
            ;;
        java)
            echo "[JAVA] Compiling: $filename -> bin/"
            output=$(javac -d bin "$file" 2>&1)
            status=$?

            if [[ $status -eq 0 ]]; then
                echo "[ OK ] bin/${name}.class"
                compiled=$((compiled + 1))
            else
                echo "[FAIL] Compilation failed: $filename"
                errors=$((errors + 1))
                error_files+=("$filename")
                $INFO && echo "$output"
            fi
            continue
            ;;
        *)
            echo "[SKIP] Unsupported extension: $filename"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            echo "[WARN] bin/$output_name compiled with warnings"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
            $INFO && echo "$output"
        else
            echo "[ OK ] bin/$output_name"
        fi
        compiled=$((compiled + 1))
    else
        echo "[FAIL] Compilation failed: $filename"
        errors=$((errors + 1))
        error_files+=("$filename")
        $INFO && echo "$output"
    fi

done

echo
echo "================= Build Report ==================="
echo "Compiled successfully : $compiled"
echo "Warnings             : $warnings"
echo "Errors               : $errors"
echo "Unsupported files    : $unsupported"

if [[ $warnings -gt 0 ]]; then
    echo "-> Warnings in:"
    for w in "${warning_files[@]}"; do
        echo "   - $w"
    done
fi

if [[ $errors -gt 0 ]]; then
    echo "-> Errors in:"
    for e in "${error_files[@]}"; do
        echo "   - $e"
    done
fi

if [[ $unsupported -gt 0 ]]; then
    echo "-> Unsupported files:"
    for u in "${unsupported_files[@]}"; do
        echo "   - $u"
    done
fi

echo "=================================================="
        		</code></pre>
			</div>

            <br>
			<h2>3. Toques finais e melhorias práticas</h2>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
adicione a funcionalidade de gerar um arquivo de log, se ele
ja existir nao o sobreponha, continue no final do arquivo. 
O arquvo de log deve ter o nome .vibeBuild.log, e nele deve
haver a data e hora de quando o comando foi rodado, o sistema,
usuario, nome do codigo fonte, diretorio atual, tipo de 
processamento, shebang, se foi copia (quando ja tem shebang), 
compilacao, etc, nome do arquivo gerado, diretorio de saida, 
se foi sucesso, se houve warning, se houve erro, warning e erro 
tem q estar no log, arquivos nao suportados, etc. se teve 
conflito, e a decisao tomada, o nome que foi alterado se a 
opção for 'y', etc. deixe os output coloridos também, por 
exemplo erro em vermelho, etc.
            </pre>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# === Colors ===
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# === Log File ===
LOG_FILE=".vibeBuild.log"

# === Create bin directory ===
mkdir -p bin

# === Parse flags ===
INFO=false
while [[ "$1" == "--info" || "$1" == "-i" ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
    esac
    shift
done

# === Stats ===
compiled=0
warnings=0
errors=0
unsupported=0

warning_files=()
error_files=()
unsupported_files=()

# === Used Names ===
declare -A used_names

# === Assume No All ===
ASSUME_NO_ALL=false

# === Start Log ===
{
    echo "========================="
    echo "Date: $(date)"
    echo "User: $(whoami)"
    echo "System: $(uname -a)"
    echo "Directory: $(pwd)"
    echo "========================="
} >> "$LOG_FILE"

echo -e "${BLUE}============== Compilation Started ==============${NC}"

# === Process Files ===
for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        echo -e "[${YELLOW}SKIP${NC}] File not found: $file"
        echo "[SKIP] File not found: $file" >> "$LOG_FILE"
        unsupported=$((unsupported + 1))
        unsupported_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"

    output_name="$name"

    # === Name conflict check ===
    if [[ -n "${used_names[$output_name]}" ]]; then
        echo -e "${YELLOW}Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'.${NC}"
        echo "Conflict: Name 'bin/$output_name' is already used for '${used_names[$output_name]}'." >> "$LOG_FILE"

        if $ASSUME_NO_ALL; then
            output_name="${name}_${ext}"
            echo "-> Auto renaming to bin/$output_name due to previous 'a' choice."
            echo "Decision: Auto rename to '$output_name' due to 'a' flag." >> "$LOG_FILE"
        else
            while true; do
                echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                read -n 1 -r choice
                echo
                if [[ "$choice" =~ ^[Yy]$ ]]; then
                    while true; do
                        read -p "Enter new name for '$filename': " newname
                        if [[ -z "$newname" ]]; then
                            echo "Name cannot be empty."
                            continue
                        fi
                        if [[ -n "${used_names[$newname]}" ]]; then
                            echo "Name 'bin/$newname' is already used for '${used_names[$newname]}'."
                            continue
                        fi
                        output_name="$newname"
                        echo "Decision: Manual rename to '$output_name'." >> "$LOG_FILE"
                        break
                    done
                    break
                elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                    output_name="${name}_${ext}"
                    echo "Decision: Auto rename to '$output_name'." >> "$LOG_FILE"
                    break
                elif [[ "$choice" =~ ^[Aa]$ ]]; then
                    output_name="${name}_${ext}"
                    ASSUME_NO_ALL=true
                    echo "Decision: Apply 'name_ext' for all next conflicts." >> "$LOG_FILE"
                    break
                else
                    echo "Please answer y, n or a."
                fi
            done
        fi
    fi

    used_names["$output_name"]="$filename"

    # === Compilation ===
    case "$ext" in
        c)
            echo -e "[${BLUE}C${NC}   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            type="C Compilation"
            ;;
        cpp|cc|cxx)
            echo -e "[${BLUE}C++${NC} ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "bin/$output_name" 2>&1)
            status=$?
            type="C++ Compilation"
            ;;
        rs)
            echo -e "[${BLUE}Rust${NC}] Compiling: $filename -> bin/$output_name"
            output=$(rustc "$file" -o "bin/$output_name" 2>&1)
            status=$?
            type="Rust Compilation"
            ;;
        go)
            echo -e "[${BLUE}Go${NC}  ] Compiling: $filename -> bin/$output_name"
            output=$(go build -o "bin/$output_name" "$file" 2>&1)
            status=$?
            type="Go Compilation"
            ;;
        java)
            echo -e "[${BLUE}Java${NC}] Compiling: $filename -> bin/"
            output=$(javac "$file" -d bin 2>&1)
            status=$?
            output_name="${name}.class"
            type="Java Compilation"
            ;;
        py)
            echo -e "[${BLUE}PY${NC}  ] Processing: $filename -> bin/$output_name"
            type="Python Script"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "bin/$output_name"
                shebang="present"
                action="Copy"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env python3'; cat "$file"; } > "bin/$output_name"
                shebang="added"
                action="Shebang Added + Copy"
            fi
            chmod +x "bin/$output_name"
            echo -e "[${GREEN}OK${NC} ] bin/$output_name"
            echo "Processed: $filename -> bin/$output_name ($action)" >> "$LOG_FILE"
            echo "Type: $type | Shebang: $shebang | Status: OK" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            echo -e "[${BLUE}JS${NC}  ] Processing: $filename -> bin/$output_name"
            type="JavaScript Script"
            if grep -q '^#!.*node' "$file"; then
                cp "$file" "bin/$output_name"
                shebang="present"
                action="Copy"
            else
                echo "Adding shebang to $filename"
                { echo '#!/usr/bin/env node'; cat "$file"; } > "bin/$output_name"
                shebang="added"
                action="Shebang Added + Copy"
            fi
            chmod +x "bin/$output_name"
            echo -e "[${GREEN}OK${NC} ] bin/$output_name"
            echo "Processed: $filename -> bin/$output_name ($action)" >> "$LOG_FILE"
            echo "Type: $type | Shebang: $shebang | Status: OK" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        *)
            echo -e "[${YELLOW}SKIP${NC}] Unsupported extension: $filename"
            echo "[SKIP] Unsupported extension: $filename" >> "$LOG_FILE"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    # === Handle Compilation Result ===
    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            echo -e "[${YELLOW}WARN${NC}] bin/$output_name compiled with warnings"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
            $INFO && echo "$output"
            echo "Type: $type | Status: WARN | Output: bin/$output_name" >> "$LOG_FILE"
            echo "Warnings:" >> "$LOG_FILE"
            echo "$output" >> "$LOG_FILE"
        else
            echo -e "[${GREEN}OK${NC} ] bin/$output_name"
            echo "Type: $type | Status: OK | Output: bin/$output_name" >> "$LOG_FILE"
        fi
        compiled=$((compiled + 1))
    else
        echo -e "[${RED}FAIL${NC}] Compilation failed: $filename"
        errors=$((errors + 1))
        error_files+=("$filename")
        $INFO && echo "$output"
        echo "Type: $type | Status: FAIL | File: $filename" >> "$LOG_FILE"
        echo "Errors:" >> "$LOG_FILE"
        echo "$output" >> "$LOG_FILE"
    fi
done

# === Build Report ===
echo
echo -e "${BLUE}================= Build Report ===================${NC}"
echo "Compiled successfully : $compiled"
echo "Warnings             : $warnings"
echo "Errors               : $errors"
echo "Unsupported files    : $unsupported"

if [[ $warnings -gt 0 ]]; then
    echo -e "-> ${YELLOW}Warnings in:${NC}"
    for w in "${warning_files[@]}"; do
        echo "   - $w"
    done
fi

if [[ $errors -gt 0 ]]; then
    echo -e "-> ${RED}Errors in:${NC}"
    for e in "${error_files[@]}"; do
        echo "   - $e"
    done
fi

if [[ $unsupported -gt 0 ]]; then
    echo "-> Unsupported files:"
    for u in "${unsupported_files[@]}"; do
        echo "   - $u"
    done
fi

echo -e "${BLUE}==================================================${NC}"
echo "==================================================" >> "$LOG_FILE"
        		</code></pre>
<img src="https://i.ibb.co/jv8pXV4y/s8.png" alt="VibeBuild output">
			</div>
            <br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
adicione um --quiet, um --help, e toda vez que
rodar o codigo, pergunte se tem certeza de excluir
todo o conteudo de bin/ e excluir tudo de bin/ 
antes de compilar os códigos. deve possuir -q e
-h como alternativas respectivamente. Se não 
houver input file, não limpe bin/. Além disso,
caso não houver o arquivo de entrada, mostre na 
saída que o arquivo não foi encontrado, pois está 
sendo mostrado como unsuported file, mesmo que ele 
nem exista. Também corrija um pequeno problema, 
quando houver erro, deixe em vermelho, não somente
em --run, como no relatorio também.
            </pre>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# ========== Configurações iniciais ==========
BIN_DIR="bin"
LOG_FILE=".vibeBuild.log"
mkdir -p "$BIN_DIR"

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # Reset

# ========== Opções ==========
INFO=false
QUIET=false
RUN=false

# Processa flags
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
        --quiet|-q) QUIET=true ;;
        --run|-r) RUN=true ;;
        --help|-h)
            echo -e "${BLUE}Usage:${NC} ./vibeBuild [options] [files]"
            echo "Options:"
            echo "  --info,  -i   Show compiler warnings and errors"
            echo "  --quiet, -q   Minimal output"
            echo "  --run,   -r   Compile (if needed) and run the code"
            echo "  --help,  -h   Show this help"
            exit 0
            ;;
        *) break ;;
    esac
    shift
done

# ========== Pergunta se deve limpar ==========
if [[ $# -gt 0 && $RUN == false ]]; then
    read -p "Do you want to clean '$BIN_DIR/' before building? (y/N) " choice
    if [[ "$choice" =~ ^[Yy]$ ]]; then
        rm -rf "$BIN_DIR"/*
        echo "Cleaned '$BIN_DIR/'"
    fi
fi

# ========== Inicializa contadores ==========
compiled=0
warnings=0
errors=0
unsupported=0
notfound=0

warning_files=()
error_files=()
unsupported_files=()
notfound_files=()

declare -A used_names
ASSUME_NO_ALL=false

# ========== Inicia log ==========
{
echo
echo "========== Build Started =========="
echo "Date: $(date)"
echo "User: $USER"
echo "System: $(uname -a)"
echo "Directory: $(pwd)"
} >> "$LOG_FILE"

# ========== Começa compilação ou execução ==========
$QUIET || echo -e "${BLUE}============== Process Started ==============${NC}"

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        $QUIET || echo -e "${YELLOW}[NOT FOUND] File not found: $file${NC}"
        echo "[NOT FOUND] File not found: $file" >> "$LOG_FILE"
        notfound=$((notfound + 1))
        notfound_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"
    output_name="$name"

    # Para --run não precisa tratar conflito de nomes
    if [[ "$RUN" == false ]]; then
        if [[ -n "${used_names[$output_name]}" ]]; then
            $QUIET || echo -e "${YELLOW}Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'${NC}"
            echo "[CONFLICT] bin/$output_name already used by ${used_names[$output_name]}" >> "$LOG_FILE"

            if $ASSUME_NO_ALL; then
                output_name="${name}_${ext}"
                $QUIET || echo "-> Automatically renaming '$filename' to bin/$output_name"
                echo "[RESOLVE] Auto rename to $output_name (previous A choice)" >> "$LOG_FILE"
            else
                while true; do
                    echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                    read -n 1 -r choice
                    echo
                    if [[ "$choice" =~ ^[Yy]$ ]]; then
                        while true; do
                            read -p "Enter new name: " newname
                            if [[ -z "$newname" ]]; then
                                echo "Name cannot be empty."
                                continue
                            fi
                            if [[ -n "${used_names[$newname]}" ]]; then
                                echo "Name 'bin/$newname' already used."
                                continue
                            fi
                            output_name="$newname"
                            echo "[RESOLVE] Manual rename to $output_name" >> "$LOG_FILE"
                            break
                        done
                        break
                    elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                        output_name="${name}_${ext}"
                        echo "[RESOLVE] Auto rename to $output_name" >> "$LOG_FILE"
                        break
                    elif [[ "$choice" =~ ^[Aa]$ ]]; then
                        output_name="${name}_${ext}"
                        ASSUME_NO_ALL=true
                        echo "-> Automatically applying 'name_ext' for next conflicts."
                        echo "[RESOLVE] Auto rename to $output_name (A selected)" >> "$LOG_FILE"
                        break
                    else
                        echo "Please answer y, n or a."
                    fi
                done
            fi
        fi
        used_names["$output_name"]="$filename"
    fi

    # ========== RUN ==========
    if [[ "$RUN" == true ]]; then
        tmpfile="/tmp/vibe_tmp_$(date +%s%N)_$RANDOM"
        trap "rm -f $tmpfile; exit" INT TERM

        case "$ext" in
            py)
                $QUIET || echo "[PY  ] Running: $filename"
                if grep -q '^#!.*python' "$file"; then
                    "$file"
                else
                    python3 "$file"
                fi
                ;;
            js)
                $QUIET || echo "[JS  ] Running: $filename"
                if grep -q '^#!.*node' "$file"; then
                    "$file"
                else
                    node "$file"
                fi
                ;;
            c)
                $QUIET || echo "[C   ] Compiling & Running: $filename"
                gcc "$file" -o "$tmpfile"
                if [[ $? -eq 0 ]]; then
                    "$tmpfile"
                else
                    echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
                fi
                ;;
            cpp|cc|cxx|c++)
                $QUIET || echo "[C++ ] Compiling & Running: $filename"
                g++ "$file" -o "$tmpfile"
                if [[ $? -eq 0 ]]; then
                    "$tmpfile"
                else
                    echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
                fi
                ;;
            rs)
                $QUIET || echo "[RS  ] Compiling & Running: $filename"
                rustc "$file" -o "$tmpfile"
                if [[ $? -eq 0 ]]; then
                    "$tmpfile"
                else
                    echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
                fi
                ;;
            go)
                $QUIET || echo "[GO  ] Compiling & Running: $filename"
                go build -o "$tmpfile" "$file"
                if [[ $? -eq 0 ]]; then
                    "$tmpfile"
                else
                    echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
                fi
                ;;
            java)
                $QUIET || echo "[JAVA] Compiling & Running: $filename"
                class_name=$(basename "$file" .java)
                javac "$file" -d /tmp
                if [[ $? -eq 0 ]]; then
                    java -cp /tmp "$class_name"
                    rm -f "/tmp/$class_name.class"
                else
                    echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
                fi
                ;;
            *)
                $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension for run: $filename${NC}"
                ;;
        esac

        rm -f "$tmpfile"
        continue
    fi

    # ========== BUILD NORMAL ==========
    case "$ext" in
        c)
            $QUIET || echo "[C   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx|c++)
            $QUIET || echo "[C++ ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        py)
            $QUIET || echo "[PY  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang="(has shebang)"
            else
                echo '#!/usr/bin/env python3' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang="(added shebang)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[PY] $filename -> bin/$output_name $shebang" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            $QUIET || echo "[JS  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*node' "$file"; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang="(has shebang)"
            else
                echo '#!/usr/bin/env node' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang="(added shebang)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[JS] $filename -> bin/$output_name $shebang" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        rs)
            $QUIET || echo "[RS  ] Compiling: $filename -> bin/$output_name"
            output=$(rustc "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        go)
            $QUIET || echo "[GO  ] Compiling: $filename -> bin/$output_name"
            output=$(go build -o "$BIN_DIR/$output_name" "$file" 2>&1)
            status=$?
            ;;
        java)
            $QUIET || echo "[JAVA] Compiling: $filename -> bin/"
            output=$(javac "$file" -d "$BIN_DIR" 2>&1)
            status=$?
            output_name="$name.class"
            ;;
        *)
            $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension: $filename${NC}"
            echo "[SKIP] Unsupported: $filename" >> "$LOG_FILE"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    # ========== Avaliação ==========
    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            $QUIET || echo -e "${YELLOW}[WARN] bin/$output_name compiled with warnings${NC}"
            echo "[WARN] bin/$output_name" >> "$LOG_FILE"
            $INFO && echo "$output"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
        else
            $QUIET || echo -e "${GREEN}[ OK ] bin/$output_name${NC}"
            echo "[OK] bin/$output_name" >> "$LOG_FILE"
        fi
        compiled=$((compiled + 1))
    else
        $QUIET || echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
        echo "[FAIL] $filename" >> "$LOG_FILE"
        $INFO && echo "$output"
        errors=$((errors + 1))
        error_files+=("$filename")
    fi

done

# ========== Relatório ==========
if [[ "$RUN" == false ]]; then
    echo
    echo -e "${BLUE}================= Build Report ===================${NC}"
    echo -e "Compiled successfully : ${GREEN}$compiled${NC}"
    echo -e "Warnings              : ${YELLOW}$warnings${NC}"
    echo -e "Errors                : ${RED}$errors${NC}"
    echo -e "Unsupported files     : ${YELLOW}$unsupported${NC}"
    echo -e "Not found files       : ${YELLOW}$notfound${NC}"

    if [[ $warnings -gt 0 ]]; then
        echo -e "${YELLOW}-> Warnings in:${NC}"
        for w in "${warning_files[@]}"; do
            echo "   - $w"
        done
    fi
    if [[ $errors -gt 0 ]]; then
        echo -e "${RED}-> Errors in:${NC}"
        for e in "${error_files[@]}"; do
            echo "   - $e"
        done
    fi
    if [[ $unsupported -gt 0 ]]; then
        echo -e "${YELLOW}-> Unsupported files:${NC}"
        for u in "${unsupported_files[@]}"; do
            echo "   - $u"
        done
    fi
    if [[ $notfound -gt 0 ]]; then
        echo -e "${YELLOW}-> Not found files:${NC}"
        for n in "${notfound_files[@]}"; do
            echo "   - $n"
        done
    fi
    echo -e "${BLUE}==================================================${NC}"
    echo "========== Build Finished ==========" >> "$LOG_FILE"
fi
                </code></pre>
<img src="https://i.ibb.co/ycQ1D7ZS/s9.png" alt="VibeBuild output">
			</div>
            <br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
quando o comando for chamado sem parâmetro algum, 
deve-se chamar o --help. No help adicione a seguinte
logo:
┌─────────────────────────────────────────────────┐
│      O       Idealized By:       Programmed By  │
│     _|_   Renato Lóis M. Silva     ChatGPT4o    │
│    /   \  Luiz Eduardo G. Cidade                │
│    () ()  Davi Eduardo S. de Lima               │
│   ,|_ _|,                                       │
│ _/_______\_ ....          VibeBuild             │
│ \  < / >  / |--|)                               │
│  \_______/  |__|  One script to build them all  │ 
│                                                 │
│           https://vibebuild.github.io/          │
└─────────────────────────────────────────────────┘
            </pre>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# ========== Configurações iniciais ==========
BIN_DIR="bin"
LOG_FILE=".vibeBuild.log"
mkdir -p "$BIN_DIR"

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # Reset

# ========== Opções ==========
INFO=false
QUIET=false
RUN=false

# Se nenhum parâmetro for passado, mostra o help
if [[ $# -eq 0 ]]; then
    set -- --help
fi

# Processa flags
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
        --quiet|-q) QUIET=true ;;
        --run|-r) RUN=true ;;
        --help|-h)
            echo -e "${BLUE}"
            cat << "EOF"
┌─────────────────────────────────────────────────┐
│      O       Idealized By:       Programmed By  │
│     _|_   Renato Lóis M. Silva     ChatGPT4o    │
│    /   \  Luiz Eduardo G. Cidade                │
│    () ()  Davi Eduardo S. de Lima               │
│   ,|_ _|,                                       │
│ _/_______\_ ....          VibeBuild             │
│ \  < / >  / |--|)                               │
│  \_______/  |__|  One script to build them all  │
│                                                 │
│           https://vibebuild.github.io/          │
└─────────────────────────────────────────────────┘
EOF
            echo -e "${NC}"
            echo -e "${BLUE}Usage:${NC} ./vibeBuild [options] [files]"
            echo "Options:"
            echo "  --info,  -i   Show compiler warnings and errors"
            echo "  --quiet, -q   Minimal output"
            echo "  --run,   -r   Compile (if needed) and run the code"
            echo "  --help,  -h   Show this help"
            exit 0
            ;;
        *) break ;;
    esac
    shift
done

# ========== Pergunta se deve limpar ==========
if [[ $# -gt 0 && $RUN == false ]]; then
    read -p "Do you want to clean '$BIN_DIR/' before building? (y/N) " choice
    if [[ "$choice" =~ ^[Yy]$ ]]; then
        rm -rf "$BIN_DIR"/*
        echo "Cleaned '$BIN_DIR/'"
    fi
fi

# ========== Inicializa contadores ==========
compiled=0
warnings=0
errors=0
unsupported=0
notfound=0

warning_files=()
error_files=()
unsupported_files=()
error_files=()
notfound_files=()

declare -A used_names
ASSUME_NO_ALL=false

# ========== Inicia log ==========
{
echo
echo "========== Build Started =========="
echo "Date: $(date)"
echo "User: $USER"
echo "System: $(uname -a)"
echo "Directory: $(pwd)"
} >> "$LOG_FILE"

# ========== Começa compilação ou execução ==========
$QUIET || echo -e "${BLUE}============== Process Started ==============${NC}"

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        $QUIET || echo -e "${RED}[NOT FOUND] File not found: $file${NC}"
        echo "[NOT FOUND] File not found: $file" >> "$LOG_FILE"
        notfound=$((notfound + 1))
        notfound_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"
    output_name="$name"

    if [[ "$RUN" == false ]]; then
        if [[ -n "${used_names[$output_name]}" ]]; then
            $QUIET || echo -e "${YELLOW}Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'${NC}"
            echo "[CONFLICT] bin/$output_name already used by ${used_names[$output_name]}" >> "$LOG_FILE"

            if $ASSUME_NO_ALL; then
                output_name="${name}_${ext}"
                $QUIET || echo "-> Automatically renaming '$filename' to bin/$output_name"
                echo "[RESOLVE] Auto rename to $output_name (previous A choice)" >> "$LOG_FILE"
            else
                while true; do
                    echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                    read -n 1 -r choice
                    echo
                    if [[ "$choice" =~ ^[Yy]$ ]]; then
                        while true; do
                            read -p "Enter new name: " newname
                            if [[ -z "$newname" ]]; then
                                echo "Name cannot be empty."
                                continue
                            fi
                            if [[ -n "${used_names[$newname]}" ]]; then
                                echo "Name 'bin/$newname' already used."
                                continue
                            fi
                            output_name="$newname"
                            echo "[RESOLVE] Manual rename to $output_name" >> "$LOG_FILE"
                            break
                        done
                        break
                    elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                        output_name="${name}_${ext}"
                        echo "[RESOLVE] Auto rename to $output_name" >> "$LOG_FILE"
                        break
                    elif [[ "$choice" =~ ^[Aa]$ ]]; then
                        output_name="${name}_${ext}"
                        ASSUME_NO_ALL=true
                        echo "-> Automatically applying 'name_ext' for next conflicts."
                        echo "[RESOLVE] Auto rename to $output_name (A selected)" >> "$LOG_FILE"
                        break
                    else
                        echo "Please answer y, n or a."
                    fi
                done
            fi
        fi
        used_names["$output_name"]="$filename"
    fi

    # ========== RUN ==========
    if [[ "$RUN" == true ]]; then
        tmpfile="/tmp/vibe_tmp_$(date +%s%N)_$RANDOM"
        trap "rm -f $tmpfile; exit" INT TERM

        case "$ext" in
            py)
                $QUIET || echo "[PY  ] Running: $filename"
                if grep -q '^#!.*python' "$file"; then
                    "$file"
                else
                    python3 "$file"
                fi
                ;;
            js)
                $QUIET || echo "[JS  ] Running: $filename"
                if grep -q '^#!.*node' "$file"; then
                    "$file"
                else
                    node "$file"
                fi
                ;;
            c)
                $QUIET || echo "[C   ] Compiling & Running: $filename"
                gcc "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            cpp|cc|cxx|c++)
                $QUIET || echo "[C++ ] Compiling & Running: $filename"
                g++ "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            rs)
                $QUIET || echo "[RS  ] Compiling & Running: $filename"
                rustc "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            go)
                $QUIET || echo "[GO  ] Compiling & Running: $filename"
                go build -o "$tmpfile" "$file" && "$tmpfile"
                ;;
            java)
                $QUIET || echo "[JAVA] Compiling & Running: $filename"
                class_name=$(basename "$file" .java)
                javac "$file" -d /tmp && java -cp /tmp "$class_name"
                rm -f "/tmp/$class_name.class"
                ;;
            *)
                $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension for run: $filename${NC}"
                ;;
        esac

        rm -f "$tmpfile"
        continue
    fi

    # ========== BUILD ==========
    case "$ext" in
        c)
            $QUIET || echo "[C   ] Compiling: $filename -> bin/$output_name"
            output=$(gcc "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx|c++)
            $QUIET || echo "[C++ ] Compiling: $filename -> bin/$output_name"
            output=$(g++ "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        py)
            $QUIET || echo "[PY  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*python' "$file"; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang="(has shebang)"
            else
                echo '#!/usr/bin/env python3' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang="(added shebang)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[PY] $filename -> bin/$output_name $shebang" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            $QUIET || echo "[JS  ] Processing: $filename -> bin/$output_name"
            if grep -q '^#!.*node' "$file"; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang="(has shebang)"
            else
                echo '#!/usr/bin/env node' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang="(added shebang)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[JS] $filename -> bin/$output_name $shebang" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        rs)
            $QUIET || echo "[RS  ] Compiling: $filename -> bin/$output_name"
            output=$(rustc "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        go)
            $QUIET || echo "[GO  ] Compiling: $filename -> bin/$output_name"
            output=$(go build -o "$BIN_DIR/$output_name" "$file" 2>&1)
            status=$?
            ;;
        java)
            $QUIET || echo "[JAVA] Compiling: $filename -> bin/"
            output=$(javac "$file" -d "$BIN_DIR" 2>&1)
            status=$?
            output_name="$name.class"
            ;;
        *)
            $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension: $filename${NC}"
            echo "[SKIP] Unsupported: $filename" >> "$LOG_FILE"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    # ========== Avaliação ==========
    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            $QUIET || echo -e "${YELLOW}[WARN] bin/$output_name compiled with warnings${NC}"
            echo "[WARN] bin/$output_name" >> "$LOG_FILE"
            $INFO && echo "$output"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
        else
            $QUIET || echo -e "${GREEN}[ OK ] bin/$output_name${NC}"
            echo "[OK] bin/$output_name" >> "$LOG_FILE"
        fi
        compiled=$((compiled + 1))
    else
        $QUIET || echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
        echo "[FAIL] $filename" >> "$LOG_FILE"
        $INFO && echo "$output"
        errors=$((errors + 1))
        error_files+=("$filename")
    fi

done

# ========== Relatório ==========
if [[ "$RUN" == false ]]; then
    echo
    echo -e "${BLUE}================= Build Report ===================${NC}"
    echo "Compiled successfully : $compiled"
    echo "Warnings              : $warnings"
    echo -e "Errors                : ${RED}$errors${NC}"
    echo "Unsupported files     : $unsupported"
    echo "Not found files       : $notfound"

    if [[ $warnings -gt 0 ]]; then
        echo "-> Warnings in:"
        for w in "${warning_files[@]}"; do
            echo "   - $w"
        done
    fi
    if [[ $errors -gt 0 ]]; then
        echo "-> Errors in:"
        for e in "${error_files[@]}"; do
            echo "   - $e"
        done
    fi
    if [[ $unsupported -gt 0 ]]; then
        echo "-> Unsupported files:"
        for u in "${unsupported_files[@]}"; do
            echo "   - $u"
        done
    fi
    if [[ $notfound -gt 0 ]]; then
        echo "-> Not found files:"
        for n in "${notfound_files[@]}"; do
            echo "   - $n"
        done
    fi
    echo -e "${BLUE}==================================================${NC}"
    echo "========== Build Finished ==========" >> "$LOG_FILE"
fi
        		</code></pre>
			</div>
            
            <br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
por último, consiga receber a opção --clang para usar
lang em vez de gnu c compiler. nos logs especifique
o tipo de shebang que sera inserido, ou se ja existe, 
mostre o ja existente, e mostre o compilador ou 
interpretador usado no momento, com seu caminho completo.
envie o codigo apos essas alterações.</pre>
			<p><strong>Versão desenvolvida:</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# ========== Configurações iniciais ==========
BIN_DIR="bin"
LOG_FILE=".vibeBuild.log"
mkdir -p "$BIN_DIR"

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# ========== Opções ==========
INFO=false
QUIET=false
RUN=false
USE_CLANG=false

# Se nenhum parâmetro for passado, mostra o help
if [[ $# -eq 0 ]]; then
    set -- --help
fi

# Processa flags
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
        --quiet|-q) QUIET=true ;;
        --run|-r) RUN=true ;;
        --clang) USE_CLANG=true ;;
        --help|-h)
            echo -e "${BLUE}"
            cat << "EOF"
┌─────────────────────────────────────────────────┐
│      O       Idealized By:       Programmed By  │
│     _|_   Renato Lóis M. Silva     ChatGPT4o    │
│    /   \  Luiz Eduardo G. Cidade                │
│    () ()  Davi Eduardo S. de Lima               │
│   ,|_ _|,                                       │
│ _/_______\_ ....          VibeBuild             │
│ \  < / >  / |--|)                               │
│  \_______/  |__|  One script to build them all  │
│                                                 │
│           https://vibebuild.github.io/          │
└─────────────────────────────────────────────────┘
EOF
            echo -e "${NC}"
            echo -e "${BLUE}Usage:${NC} ./vibeBuild [options] [files]"
            echo "Options:"
            echo "  --info,  -i   Show compiler warnings and errors"
            echo "  --quiet, -q   Minimal output"
            echo "  --run,   -r   Compile (if needed) and run the code"
            echo "  --clang       Use clang/clang++ instead of gcc/g++"
            echo "  --help,  -h   Show this help"
            exit 0
            ;;
        *) break ;;
    esac
    shift
done

# Configura compiladores
CC=$(command -v gcc)
CXX=$(command -v g++)
if $USE_CLANG; then
    CC=$(command -v clang)
    CXX=$(command -v clang++)
fi

# ========== Pergunta se deve limpar ==========
if [[ $# -gt 0 && $RUN == false ]]; then
    read -p "Do you want to clean '$BIN_DIR/' before building? (y/N) " choice
    if [[ "$choice" =~ ^[Yy]$ ]]; then
        rm -rf "$BIN_DIR"/*
        echo "Cleaned '$BIN_DIR/'"
    fi
fi

# ========== Inicializa contadores ==========
compiled=0
warnings=0
errors=0
unsupported=0
notfound=0

warning_files=()
error_files=()
unsupported_files=()
notfound_files=()

declare -A used_names
ASSUME_NO_ALL=false

# ========== Inicia log ==========
{
echo
echo "========== Build Started =========="
echo "Date: $(date)"
echo "User: $USER"
echo "System: $(uname -a)"
echo "Directory: $(pwd)"
echo "C Compiler: $CC"
echo "C++ Compiler: $CXX"
echo "Python: $(command -v python3)"
echo "Node.js: $(command -v node)"
echo "Rust: $(command -v rustc)"
echo "Go: $(command -v go)"
echo "Java: $(command -v javac) / $(command -v java)"
} >> "$LOG_FILE"

# ========== Começa compilação ou execução ==========
$QUIET || echo -e "${BLUE}============== Process Started ==============${NC}"

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        $QUIET || echo -e "${RED}[NOT FOUND] File not found: $file${NC}"
        echo "[NOT FOUND] File not found: $file" >> "$LOG_FILE"
        notfound=$((notfound + 1))
        notfound_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"
    output_name="$name"

    if [[ "$RUN" == false ]]; then
        if [[ -n "${used_names[$output_name]}" ]]; then
            $QUIET || echo -e "${YELLOW}Name 'bin/$output_name' is already in use for '${used_names[$output_name]}'${NC}"
            echo "[CONFLICT] bin/$output_name already used by ${used_names[$output_name]}" >> "$LOG_FILE"

            if $ASSUME_NO_ALL; then
                output_name="${name}_${ext}"
                $QUIET || echo "-> Automatically renaming '$filename' to bin/$output_name"
                echo "[RESOLVE] Auto rename to $output_name (previous A choice)" >> "$LOG_FILE"
            else
                while true; do
                    echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                    read -n 1 -r choice
                    echo
                    if [[ "$choice" =~ ^[Yy]$ ]]; then
                        while true; do
                            read -p "Enter new name: " newname
                            if [[ -z "$newname" ]]; then
                                echo "Name cannot be empty."
                                continue
                            fi
                            if [[ -n "${used_names[$newname]}" ]]; then
                                echo "Name 'bin/$newname' already used."
                                continue
                            fi
                            output_name="$newname"
                            echo "[RESOLVE] Manual rename to $output_name" >> "$LOG_FILE"
                            break
                        done
                        break
                    elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                        output_name="${name}_${ext}"
                        echo "[RESOLVE] Auto rename to $output_name" >> "$LOG_FILE"
                        break
                    elif [[ "$choice" =~ ^[Aa]$ ]]; then
                        output_name="${name}_${ext}"
                        ASSUME_NO_ALL=true
                        echo "-> Automatically applying 'name_ext' for next conflicts."
                        echo "[RESOLVE] Auto rename to $output_name (A selected)" >> "$LOG_FILE"
                        break
                    else
                        echo "Please answer y, n or a."
                    fi
                done
            fi
        fi
        used_names["$output_name"]="$filename"
    fi

    # ========== RUN ==========
    if [[ "$RUN" == true ]]; then
        tmpfile="/tmp/vibe_tmp_$(date +%s%N)_$RANDOM"
        trap "rm -f $tmpfile; exit" INT TERM

        case "$ext" in
            py)
                interp=$(command -v python3)
                $QUIET || echo "[PY  ] Running: $filename ($interp)"
                if grep -q '^#!.*python' "$file"; then
                    "$file"
                else
                    "$interp" "$file"
                fi
                ;;
            js)
                interp=$(command -v node)
                $QUIET || echo "[JS  ] Running: $filename ($interp)"
                if grep -q '^#!.*node' "$file"; then
                    "$file"
                else
                    "$interp" "$file"
                fi
                ;;
            c)
                $QUIET || echo "[C   ] Compiling & Running: $filename ($CC)"
                "$CC" "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            cpp|cc|cxx|c++)
                $QUIET || echo "[C++ ] Compiling & Running: $filename ($CXX)"
                "$CXX" "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            rs)
                rustc_path=$(command -v rustc)
                $QUIET || echo "[RS  ] Compiling & Running: $filename ($rustc_path)"
                rustc "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            go)
                go_path=$(command -v go)
                $QUIET || echo "[GO  ] Compiling & Running: $filename ($go_path)"
                go build -o "$tmpfile" "$file" && "$tmpfile"
                ;;
            java)
                javac_path=$(command -v javac)
                java_path=$(command -v java)
                class_name=$(basename "$file" .java)
                $QUIET || echo "[JAVA] Compiling & Running: $filename ($javac_path/$java_path)"
                javac "$file" -d /tmp && java -cp /tmp "$class_name"
                rm -f "/tmp/$class_name.class"
                ;;
            *)
                $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension for run: $filename${NC}"
                ;;
        esac

        rm -f "$tmpfile"
        continue
    fi

    # ========== BUILD ==========
    case "$ext" in
        c)
            $QUIET || echo "[C   ] Compiling: $filename -> bin/$output_name ($CC)"
            output=$("$CC" "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx|c++)
            $QUIET || echo "[C++ ] Compiling: $filename -> bin/$output_name ($CXX)"
            output=$("$CXX" "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        py)
            interp=$(command -v python3)
            shebang=$(grep -m1 '^#!' "$file")
            if [[ -n "$shebang" ]]; then
                info="(has shebang: $shebang)"
            else
                echo '#!/usr/bin/env python3' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                info="(added shebang: #!/usr/bin/env python3)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[PY] $filename -> bin/$output_name $info (interpreter: $interp)" >> "$LOG_FILE"
            $QUIET || echo "[PY  ] $filename -> bin/$output_name $info ($interp)"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            interp=$(command -v node)
            shebang=$(grep -m1 '^#!' "$file")
            if [[ -n "$shebang" ]]; then
                info="(has shebang: $shebang)"
            else
                echo '#!/usr/bin/env node' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                info="(added shebang: #!/usr/bin/env node)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            echo "[JS] $filename -> bin/$output_name $info (interpreter: $interp)" >> "$LOG_FILE"
            $QUIET || echo "[JS  ] $filename -> bin/$output_name $info ($interp)"
            compiled=$((compiled + 1))
            continue
            ;;
        rs)
            rustc_path=$(command -v rustc)
            $QUIET || echo "[RS  ] Compiling: $filename -> bin/$output_name ($rustc_path)"
            output=$(rustc "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        go)
            go_path=$(command -v go)
            $QUIET || echo "[GO  ] Compiling: $filename -> bin/$output_name ($go_path)"
            output=$(go build -o "$BIN_DIR/$output_name" "$file" 2>&1)
            status=$?
            ;;
        java)
            javac_path=$(command -v javac)
            $QUIET || echo "[JAVA] Compiling: $filename -> bin/ ($javac_path)"
            output=$(javac "$file" -d "$BIN_DIR" 2>&1)
            status=$?
            output_name="$name.class"
            ;;
        *)
            $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension: $filename${NC}"
            echo "[SKIP] Unsupported: $filename" >> "$LOG_FILE"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    # ========== Avaliação ==========
    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            $QUIET || echo -e "${YELLOW}[WARN] bin/$output_name compiled with warnings${NC}"
            echo "[WARN] bin/$output_name" >> "$LOG_FILE"
            $INFO && echo "$output"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
        else
            $QUIET || echo -e "${GREEN}[ OK ] bin/$output_name${NC}"
            echo "[OK] bin/$output_name" >> "$LOG_FILE"
        fi
        compiled=$((compiled + 1))
    else
        $QUIET || echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
        echo "[FAIL] $filename" >> "$LOG_FILE"
        $INFO && echo "$output"
        errors=$((errors + 1))
        error_files+=("$filename")
    fi

done

# ========== Relatório ==========
if [[ "$RUN" == false ]]; then
    echo
    echo -e "${BLUE}================= Build Report ===================${NC}"
    echo "Compiled successfully : $compiled"
    echo "Warnings              : $warnings"
    echo -e "Errors                : ${RED}$errors${NC}"
    echo "Unsupported files     : $unsupported"
    echo "Not found files       : $notfound"

    if [[ $warnings -gt 0 ]]; then
        echo "-> Warnings in:"
        for w in "${warning_files[@]}"; do
            echo "   - $w"
        done
    fi
    if [[ $errors -gt 0 ]]; then
        echo "-> Errors in:"
        for e in "${error_files[@]}"; do
            echo "   - $e"
        done
    fi
    if [[ $unsupported -gt 0 ]]; then
        echo "-> Unsupported files:"
        for u in "${unsupported_files[@]}"; do
            echo "   - $u"
        done
    fi
    if [[ $notfound -gt 0 ]]; then
        echo "-> Not found files:"
        for n in "${notfound_files[@]}"; do
            echo "   - $n"
        done
    fi
    echo -e "${BLUE}==================================================${NC}"
    echo "========== Build Finished ==========" >> "$LOG_FILE"
fi
        		</code></pre>
			</div>
		<div class="sub-info">
					<p>Aqui percebi um erro. em arquivos que é necessário um shebang para tornalo executável, há o erro em que o chmod não encontra o executável, pois ainda nao foi gerado em /bin. A IA corrigirá isso no próximo prompt.
					</p>
				</div>
            <br>
            <p><strong>Prompt utilizado:</strong></p>
			<pre class="prompt">
============== Process Started ==============
[C++ ] Compiling: cpp1.cpp -> bin/cpp1 (/sbin/clang++)
[ OK ] bin/cpp1
chmod: cannot access 'bin/b': No such file or directory
[PY  ] b.py -> bin/b (has shebang: #!/usr/bin/python3) (/sbin/python3)
Name 'bin/b' is already in use for 'b.py'
Do you want to enter a custom name for 'b.c'? (y/N/a) a
-> Automatically applying 'name_ext' for next conflicts.
[C   ] Compiling: b.c -> bin/b_c (/sbin/clang)
[ OK ] bin/b_c
Name 'bin/b' is already in use for 'b.py'

esse trecho do output mostra um erro, o chmod não consegue
acessar o executável. corrija-o.
além disso, adicione a opção --dest, ou -d, para definir o destino
do binário. Caso nao for especificado o diretório, envie para 
a pasta atual. Por exemplo: vibe codigo.c -d, o binário deve ser 
gerado no diretório atual. Pergunte se quer limpar o diretório 
especificado caso não seja o atual. E Adicione a opcao -y e -n para 
nao perguntar se quer limpar ou nao a pasta bin e também adicione 
isto ao --help.
            </pre>
			<p><strong>Versão desenvolvida (Final):</strong></p>
			<div class="code-container">
				<button class="copy-button" onclick="copyCode(this)">Copiar</button>
				<pre><code class="language-bash">
#!/bin/bash

# ========== Configurações iniciais ==========
BIN_DIR="bin"
LOG_FILE=".vibeBuild.log"
mkdir -p "$BIN_DIR"

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # Reset

# ========== Opções ==========
INFO=false
QUIET=false
RUN=false
USE_CLANG=false
DEST_SET=false
FORCE_CLEAN=""
ASSUME_NO_ALL=false

# Se nenhum parâmetro for passado, mostra o help
if [[ $# -eq 0 ]]; then
    set -- --help
fi

# Processa flags
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        --info|-i) INFO=true ;;
        --quiet|-q) QUIET=true ;;
        --run|-r) RUN=true ;;
        --clang) USE_CLANG=true ;;
        --dest|-d)
            DEST_SET=true
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                BIN_DIR="$2"
                shift
            else
                BIN_DIR="."
            fi
            ;;
        -y) FORCE_CLEAN="yes" ;;
        -n) FORCE_CLEAN="no" ;;
        --help|-h)
            echo -e "${BLUE}"
            cat << "EOF"
┌─────────────────────────────────────────────────┐
│      O       Idealized By:       Programmed By  │
│     _|_   Renato Lóis M. Silva     ChatGPT4o    │
│    /   \  Luiz Eduardo G. Cidade                │
│    () ()  Davi Eduardo S. de Lima               │
│   ,|_ _|,                                       │
│ _/_______\_ ....          VibeBuild             │
│ \  < / >  / |--|)                               │
│  \_______/  |__|  One script to build them all  │
│                                                 │
│           https://vibebuild.github.io/          │
└─────────────────────────────────────────────────┘
EOF
            echo -e "${NC}"
            echo -e "${BLUE}Usage:${NC} ./vibeBuild [options] [files]"
            echo "Options:"
            echo "  --info,  -i   Show compiler warnings and errors"
            echo "  --quiet, -q   Minimal output"
            echo "  --run,   -r   Compile (if needed) and run the code"
            echo "  --clang       Use clang/clang++ instead of gcc/g++"
            echo "  --dest,  -d   Set output directory (default: bin)"
            echo "  -y            Always clean bin/ before building (no prompt)"
            echo "  -n            Never clean bin/ (no prompt)"
            echo "  --help,  -h   Show this help"
            exit 0
            ;;
        *) break ;;
    esac
    shift
done

# Cria o diretório de destino se não existir
mkdir -p "$BIN_DIR"

# ========== Pergunta se deve limpar ==========
if [[ $# -gt 0 && $RUN == false && $BIN_DIR == "bin" ]]; then
    if [[ "$FORCE_CLEAN" == "yes" ]]; then
        rm -rf "bin"/*
        echo "Cleaned 'bin/' (forced)"
    elif [[ "$FORCE_CLEAN" == "no" ]]; then
        :
    else
        read -p "Do you want to clean 'bin/' before building? (y/N) " choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            rm -rf "bin"/*
            echo "Cleaned 'bin/'"
        fi
    fi
fi

# ========== Inicializa contadores ==========
compiled=0
warnings=0
errors=0
unsupported=0
notfound=0

warning_files=()
error_files=()
unsupported_files=()
notfound_files=()

declare -A used_names

# ========== Inicia log ==========
{
echo
echo "========== Build Started =========="
echo "Date: $(date)"
echo "User: $USER"
echo "System: $(uname -a)"
echo "Directory: $(pwd)"
echo "Output Directory: $BIN_DIR"
} >> "$LOG_FILE"

# ========== Detecta compiladores ==========
C_COMPILER=$(command -v gcc)
CXX_COMPILER=$(command -v g++)
if $USE_CLANG; then
    C_COMPILER=$(command -v clang)
    CXX_COMPILER=$(command -v clang++)
fi
PYTHON_INTERP=$(command -v python3)
NODE_INTERP=$(command -v node)
RUSTC=$(command -v rustc)
GO=$(command -v go)
JAVAC=$(command -v javac)
JAVA=$(command -v java)

# ========== Começa compilação ou execução ==========
$QUIET || echo -e "${BLUE}============== Process Started ==============${NC}"

for file in "$@"; do
    if [[ ! -f "$file" ]]; then
        $QUIET || echo -e "${RED}[NOT FOUND] File not found: $file${NC}"
        echo "[NOT FOUND] File not found: $file" >> "$LOG_FILE"
        notfound=$((notfound + 1))
        notfound_files+=("$file")
        continue
    fi

    filename=$(basename -- "$file")
    name="${filename%.*}"
    ext="${filename##*.}"
    output_name="$name"

    # ========== Gerenciamento de nomes ==========
    if [[ "$RUN" == false ]]; then
        if [[ -n "${used_names[$output_name]}" ]]; then
            $QUIET || echo -e "${YELLOW}Name '$BIN_DIR/$output_name' is already in use for '${used_names[$output_name]}'${NC}"
            echo "[CONFLICT] $BIN_DIR/$output_name already used by ${used_names[$output_name]}" >> "$LOG_FILE"

            if $ASSUME_NO_ALL; then
                output_name="${name}_${ext}"
                $QUIET || echo "-> Automatically renaming '$filename' to $BIN_DIR/$output_name"
                echo "[RESOLVE] Auto rename to $output_name (previous A choice)" >> "$LOG_FILE"
            else
                while true; do
                    echo -n "Do you want to enter a custom name for '$filename'? (y/N/a) "
                    read -n 1 -r choice
                    echo
                    if [[ "$choice" =~ ^[Yy]$ ]]; then
                        while true; do
                            read -p "Enter new name: " newname
                            if [[ -z "$newname" ]]; then
                                echo "Name cannot be empty."
                                continue
                            fi
                            if [[ -n "${used_names[$newname]}" ]]; then
                                echo "Name '$BIN_DIR/$newname' already used."
                                continue
                            fi
                            output_name="$newname"
                            echo "[RESOLVE] Manual rename to $output_name" >> "$LOG_FILE"
                            break
                        done
                        break
                    elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
                        output_name="${name}_${ext}"
                        echo "[RESOLVE] Auto rename to $output_name" >> "$LOG_FILE"
                        break
                    elif [[ "$choice" =~ ^[Aa]$ ]]; then
                        output_name="${name}_${ext}"
                        ASSUME_NO_ALL=true
                        echo "-> Automatically applying 'name_ext' for next conflicts."
                        echo "[RESOLVE] Auto rename to $output_name (A selected)" >> "$LOG_FILE"
                        break
                    else
                        echo "Please answer y, n or a."
                    fi
                done
            fi
        fi
        used_names["$output_name"]="$filename"
    fi

    # ========== RUN ==========
    if [[ "$RUN" == true ]]; then
        tmpfile="/tmp/vibe_tmp_$(date +%s%N)_$RANDOM"
        trap "rm -f $tmpfile; exit" INT TERM

        case "$ext" in
            py)
                $QUIET || echo "[PY  ] Running: $filename ($PYTHON_INTERP)"
                if grep -q '^#!.*python' "$file"; then
                    "$file"
                else
                    "$PYTHON_INTERP" "$file"
                fi
                ;;
            js)
                $QUIET || echo "[JS  ] Running: $filename ($NODE_INTERP)"
                if grep -q '^#!.*node' "$file"; then
                    "$file"
                else
                    "$NODE_INTERP" "$file"
                fi
                ;;
            c)
                $QUIET || echo "[C   ] Compiling & Running: $filename ($C_COMPILER)"
                "$C_COMPILER" "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            cpp|cc|cxx|c++)
                $QUIET || echo "[C++ ] Compiling & Running: $filename ($CXX_COMPILER)"
                "$CXX_COMPILER" "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            rs)
                $QUIET || echo "[RS  ] Compiling & Running: $filename ($RUSTC)"
                "$RUSTC" "$file" -o "$tmpfile" && "$tmpfile"
                ;;
            go)
                $QUIET || echo "[GO  ] Compiling & Running: $filename ($GO)"
                "$GO" build -o "$tmpfile" "$file" && "$tmpfile"
                ;;
            java)
                class_name=$(basename "$file" .java)
                $QUIET || echo "[JAVA] Compiling & Running: $filename ($JAVAC)"
                "$JAVAC" "$file" -d /tmp && "$JAVA" -cp /tmp "$class_name"
                rm -f "/tmp/$class_name.class"
                ;;
            *)
                $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension for run: $filename${NC}"
                ;;
        esac

        rm -f "$tmpfile"
        continue
    fi

    # ========== BUILD ==========
    case "$ext" in
        c)
            $QUIET || echo "[C   ] Compiling: $filename -> $BIN_DIR/$output_name ($C_COMPILER)"
            output=$("$C_COMPILER" "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        cpp|cc|cxx|c++)
            $QUIET || echo "[C++ ] Compiling: $filename -> $BIN_DIR/$output_name ($CXX_COMPILER)"
            output=$("$CXX_COMPILER" "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        py)
            shebang=$(head -n 1 "$file")
            if [[ "$shebang" =~ ^#! ]]; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang_info="(has shebang: $shebang)"
            else
                echo '#!/usr/bin/env python3' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang_info="(added shebang: #!/usr/bin/env python3)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            $QUIET || echo "[PY  ] $filename -> $BIN_DIR/$output_name $shebang_info ($PYTHON_INTERP)"
            echo "[PY] $filename -> $BIN_DIR/$output_name $shebang_info ($PYTHON_INTERP)" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        js)
            shebang=$(head -n 1 "$file")
            if [[ "$shebang" =~ ^#! ]]; then
                cp "$file" "$BIN_DIR/$output_name"
                shebang_info="(has shebang: $shebang)"
            else
                echo '#!/usr/bin/env node' > "$BIN_DIR/$output_name"
                cat "$file" >> "$BIN_DIR/$output_name"
                shebang_info="(added shebang: #!/usr/bin/env node)"
            fi
            chmod +x "$BIN_DIR/$output_name"
            $QUIET || echo "[JS  ] $filename -> $BIN_DIR/$output_name $shebang_info ($NODE_INTERP)"
            echo "[JS] $filename -> $BIN_DIR/$output_name $shebang_info ($NODE_INTERP)" >> "$LOG_FILE"
            compiled=$((compiled + 1))
            continue
            ;;
        rs)
            $QUIET || echo "[RS  ] Compiling: $filename -> $BIN_DIR/$output_name ($RUSTC)"
            output=$("$RUSTC" "$file" -o "$BIN_DIR/$output_name" 2>&1)
            status=$?
            ;;
        go)
            $QUIET || echo "[GO  ] Compiling: $filename -> $BIN_DIR/$output_name ($GO)"
            output=$("$GO" build -o "$BIN_DIR/$output_name" "$file" 2>&1)
            status=$?
            ;;
        java)
            $QUIET || echo "[JAVA] Compiling: $filename -> $BIN_DIR/ ($JAVAC)"
            output=$("$JAVAC" "$file" -d "$BIN_DIR" 2>&1)
            status=$?
            output_name="$name.class"
            ;;
        *)
            $QUIET || echo -e "${YELLOW}[SKIP] Unsupported extension: $filename${NC}"
            echo "[SKIP] Unsupported: $filename" >> "$LOG_FILE"
            unsupported=$((unsupported + 1))
            unsupported_files+=("$filename")
            continue
            ;;
    esac

    # ========== Avaliação ==========
    if [[ $status -eq 0 ]]; then
        if echo "$output" | grep -qi "warning"; then
            $QUIET || echo -e "${YELLOW}[WARN] $BIN_DIR/$output_name compiled with warnings${NC}"
            echo "[WARN] $BIN_DIR/$output_name" >> "$LOG_FILE"
            $INFO && echo "$output"
            warnings=$((warnings + 1))
            warning_files+=("$filename")
        else
            $QUIET || echo -e "${GREEN}[ OK ] $BIN_DIR/$output_name${NC}"
            echo "[OK] $BIN_DIR/$output_name" >> "$LOG_FILE"
        fi
        compiled=$((compiled + 1))
    else
        $QUIET || echo -e "${RED}[FAIL] Compilation failed: $filename${NC}"
        echo "[FAIL] $filename" >> "$LOG_FILE"
        $INFO && echo "$output"
        errors=$((errors + 1))
        error_files+=("$filename")
    fi

done

# ========== Relatório ==========
if [[ "$RUN" == false ]]; then
    echo
    echo -e "${BLUE}================= Build Report ===================${NC}"
    echo "Compiled successfully : $compiled"
    echo "Warnings              : $warnings"
    echo -e "Errors                : ${RED}$errors${NC}"
    echo "Unsupported files     : $unsupported"
    echo "Not found files       : $notfound"

    if [[ $warnings -gt 0 ]]; then
        echo "-> Warnings in:"
        for w in "${warning_files[@]}"; do
            echo "   - $w"
        done
    fi
    if [[ $errors -gt 0 ]]; then
        echo "-> Errors in:"
        for e in "${error_files[@]}"; do
            echo "   - $e"
        done
    fi
    if [[ $unsupported -gt 0 ]]; then
        echo "-> Unsupported files:"
        for u in "${unsupported_files[@]}"; do
            echo "   - $u"
        done
    fi
    if [[ $notfound -gt 0 ]]; then
        echo "-> Not found files:"
        for n in "${notfound_files[@]}"; do
            echo "   - $n"
        done
    fi
    echo -e "${BLUE}==================================================${NC}"
    echo "========== Build Finished ==========" >> "$LOG_FILE"
fi
        		</code></pre>
			</div>
				<div class="sub-info">
					<p>
A partir daqui, se torna inviável o uso do ChatGPT4o, ele não consegue mais ler completamente o código, creio que devido seu tamanho, nem reescrevê-lo completamente, o uso da flag '-d' funciona, entretanto usando-a sem argumento (que deveria gerar os binários no diretório atual) não funciona, ele acha que code.c é um diretório em <pre> vibe -d code.c </pre> ou então a flag '-d' é visto como arquivo em <pre> vibe code.c -d </pre> Por mais que em: <pre> vibe -d . code.c</pre> o problema seja "resolvido", a ia não conseguiu reestruturar a parte do código para manter a lógica dessa flag funcional caso o diretório não seja especificado
Além disso, ele também não conseguiu implementar a funcionalidade de adicionar nos logs se bin/ foi limpo, e nem deixar a logo do programa com um degradê, assim como no instalador. Devido à isso, o código não vale mais a pena ser continuado pela IA.<br><br>
Obs: enviando como arquivo ele aparenta conseguir ler tudo. Só que seus resultados não condizem com essa afirmação, gerando códigos com até metado do tamanho original.
					</p>
				</div>

<img src="https://i.ibb.co/tpNwZjpJ/nv.png" alt="ChatGPT's code" class="grande">
		</section>
		<br><br>
		<section id="conclusao">
			<h2>Conclusão</h2>
			<p>O código atingiu seu objetivo. É notável a praticidade para criação de scripts mais simples usando o vibe coding. Acredito ser muito útil para problemas simples, grandes e demorados, mas pode ser um tiro no pé para questões mais complexas como algoritmos matemáticos e sistemas críticos.
			O uso da IA, no meu caso, foi de grande ajuda pois escreveu muitas linhas em menos de um dia. Entretanto, acredito que para quem não tem muita noção do que está fazendo, nem das ferramentas que usa, o caso é diferente, como aconteceu no início quando a ideia original era usar makefile.

            Sua aplicação é bem útil, no caso usei para compilar de uma vez diversos códigos de programação competitiva.
            
            A minha opinião em relação ao projeto é positiva, mas vejo uma complexidade de levar isso além daqui.
            O uso de shell script foi interessante por causa da interabilidade com o terminal linux.

            Apesar disso, não acredito que essa forma nem de longe chegue a ser a melhor forma séria, profissional e viável de se desenvolver um software.

            No meio do caminho, parecia que seria bem sólido, de certa forma ainda está, mas com o passar do desenvolvimento provavelmente ficará inconsistente.
			</p>
            <br>
            <h3>
                Tempo total -><br>
                planejamente: 10 minutos.<br>
                desenvolvimento: cerca de 4/5 horas.<br>
                correções: 1/2 horas.<br>
                testes: menos de 1 hora, os testes não foram tão demorados.<br>
                criação do projeto no github + subir página: 30 minutos.<br>
                criação do instalador: +/- 20 minutos.<br>
                criação do site: mais ou menos 5 horas. Apenas pequena parte foi usado IA.<br>
                <br>
                obs: o tempo não está 100% preciso devido às pausas feitas durante o desenvolvimento do projeto.
            </h3>

            <br><br>
            <h4>Pontos Positivos:</h4>
            <p class="positivos"><strong>
                - A IA conseguiu desenvolver o projeto.<br>
                - O programa ficou funcional.<br>
                - O código ficou até que legível e estruturado.<br>
                - Superou minhas expectativas.<br>
                - O código final não mostrou lentidão.<br>
                - A eficiência da IA se mostrou bastante superior do que no passado.<br>
                - E ela se mostrou bastante prática e útil em casos de muito código repetido.
            </strong></p><br>
            <h4>Pontos Negativos:</h4>
            <p class="negativos"><strong>
                - É extremamente díficil aprender com este processo.<br>
                - O a aba do ChatGPT ficava muito lento a ponto de crashar o computador quando gerava o código diversas vezes (creio que pelo consumo de ram do Browser).<br>
                - É necessário ser específico, as vezes ele não faz tudo o que se espera.<br>
                - É necessário ser muito específico, as vezes ele faz o que não se espera.<br>
                - Não é dá a mesma sensação de programar.<br>
                - Impossível, ou só complicado, de afirmar que fui eu quem fiz isso.<br>
                - Se eu não fizesse por essa pesquisa, a fim de que apenas rodasse o que eu precisava, no caso de ser simples no sentido de escrever pouca coisa, sem adicionar funcionalidades, talvez levasse menos tempo.
                - Se fosse para um aplicativo real, isso iria ficando cada vez maior e mais complexo com o tempo, levando muito mais tempo.
            </strong></p><br>
            <h4>Detalhes:</h4>
            <p class="detalhes"><strong>
                - A opção "-d" não limpa o diretório, para evitar exclusão de arquivos importantes, mas poderia ser implementado, e por sorte, não foi necessário expecificar isso.<br>
                - Outro detalhe é que a opção '-d' não mostra explicitamente erro ao passar um arquivo em vez de um diretório. Entretanto, poderia ser corrigido usando a IA, mas para não prolongar muito, ficará assim mesmo, até por que é intuitivo, por mais que seja uma falha, esse script não tem o objetivo que ser super completo e desenvolvido como uma ferramenta real.<br>
                - O script estará disponível no fim da página. Faça o download ou use o instalador do projeto.<br>
                - O tempo total de construção do aplicativo de umas 5/8 horas, contando com contratempos.<br>
                - Todas as expectativas básicas foram realizadas, porém há coisas que poderiam ainda ser implementadas.<br>
                - No final acabou tendo mais funções que queriamos inicialmente (em minha opinião é um fator positivo).<br>
                - Aproveitando o embalo da situação, esse site foi utilizado um pouco de vibe coding para seu desenvolvimento.<br>
                - Diversas vezes em que pedi mais de uma coisa consecutiva, eu mostrei somente um prompt reunindo os 3 pedidos, e aqui somente mostrei o output final.<br>
                - Momentos em que a IA acabou criando coisas que nao condizia ao escopo, e depois corrigimos, não serão mostrados para não ficar um conteúdo massivo.
                - O total de versões do código até agora foram 13 versões, que são separadas por alguma(s) mudança(s) significativa(s).
            </strong></p><br>
            <h4>Sobre o desenvolvimento:</h4>
            <p class="AboutDev"><strong>
                - A idéia do projeto surgiu quando precisei compilar cada questão de https://github.com/RLois4/questoes-Obi.<br>
                - O que mais demorou provavelmente foi o tempo de espera para a IA gerar o código.<br>
                - Em momento nenhum houve quebra ou erro de funcionalidades antigas com as implementadas naquela hora.
            </strong></p><br>
            <h4>A IA ameaça o mercado de trabalho da programação?</h4>
            <p class="AboutDev"><strong>
                - Para quem trabalha com soluções simples, como criar um blog estático ou scripts de automação menores, talvez sim.<br>
                - Diria que a IA não teria capacidade nesses próximos anos para substituir igualmente um humano no seu trabalho em determinados setores da programação.<br>
                - Designs mais complexos, Backends com alta necessidade de desempenho, programação em embarcados de mais baixo nível, algoritmos matemáticos com alto grau de dificuldade que precisam de complexidades Big-O mínimos e sistemas que gerenciam dados sensíveis são exemplos de coisas que nem podemos pensar em atribuir o trabalho às IA's.
            </strong></p>
		</section>
    </section>
    <section class="about">
    <h2>Sobre o Projeto</h2>
    <div class="ascii-art">
<pre>
┌─────────────────────────────────────────────────┐
│       O       Idealizado Por:    Programado Por │
│      _|_   Renato Lóis M. Silva     ChatGPT4o   │
│     /   \  Luiz Eduardo G. Cidade               │
│     () ()  Davi Eduardo S. de Lima              │
│    ,|_ _|,                                      │
│  _/_______\_ ....         VibeBuild             │
│  \  < / >  / |--|)                              │
│   \_______/  |__|  Um script para compilar tudo │ 
│                                                 │
│          https://vibebuild.github.io/           │
└─────────────────────────────────────────────────┘
</pre>
    </div>

    <p><strong>VibeBuild</strong> é uma ferramenta simples para automação de compilação.</p>
    <p>Ela nasceu da minha necessidade de compilar pequenos trechos de código de forma rápida e prática, sem precisar configurar Makefiles ou outras ferramentas complexas.</p>
    <p>Juntando isso com uma pesquisa escolar sobre <em>vibe coding</em>, nasceu o <strong>VibeBuild</strong>.</p>

    <h3>✨ Funcionalidades</h3>
    <ul>
        <li>🛠️ Compilação rápida para pequenos códigos.</li>
        <li>🚀 Suporte a múltiplas linguagens.</li>
        <li>📜 Geração de log detalhado.</li>
        <li>🔥 Executar após compilar (<code>--run</code> ou <code>-r</code>).</li>
        <li>🏗️ Alterar de GCC pra CLANG (<code>--clang</code>).</li>
        <li>📁 Definir o diretório de saída (<code>-d</code>).</li>
    </ul>

    <h3>🚀 Como Usar</h3>
    <ol>
        <li>Clone o repositório:
            <pre class="prompt">git clone https://github.com/VibeBuild/vibebuild.github.io<br>cd vibebuild.github.io</pre>
        </li>
        <li>Deixe o instalador executável:
            <pre class="prompt">chmod +x installer</pre>
        </li>
        <li>Execute para instalar:
            <pre class="prompt">./installer</pre>
        </li>
        <li>Execute o programa:
            <pre class="prompt">vibe</pre>
        </li>
    </ol>

    <h3>🔗 Links</h3>
    <p>🔥 Projeto no GitHub: <a href="https://github.com/VibeBuild/vibebuild.github.io" target="_blank">https://github.com/VibeBuild/vibebuild.github.io</a></p>

    <h3>📜 Licença</h3>
    <p>Este projeto está licenciado sob a Licença GPL. Veja o arquivo <a href="https://github.com/VibeBuild/vibebuild.github.io/blob/main/LICENSE" target="_blank">LICENSE</a> para mais detalhes.</p>

    <blockquote>“<strong>One script to build them all.</Script></strong>”<br>— <em>VibeBuild</em></blockquote>
<img src="https://i.ibb.co/k6Kv3JdM/image.png" alt="VibeBuild output" class="noborder">
</section>

        <div class="download-container">
            <a href="https://vibebuild.github.io/VibeBuild" download class="download-button">Download</a>
        </div>

		<footer>
			<p>&copy; 2025 Vibe Build. Todos os direitos reservados.</p>
		</footer>
		<script>
			function copyCode(button) {
			    const code = button.nextElementSibling.innerText;
			    navigator.clipboard.writeText(code).then(() => {
			        button.innerText = "Copiado!";
			        setTimeout(() => {
			            button.innerText = "Copiar";
			        }, 2000);
			    });
			}
		</script>
	</body>
</html>
